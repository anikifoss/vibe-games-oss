<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Grid Bomber</title>
    <style>
        :root {
            --neon-cyan: #00ffff;
            --neon-pink: #ff00ff;
            --neon-yellow: #ffff00;
            --neon-green: #00ff00;
            --neon-red: #ff0044;
            --panel-bg: rgba(0, 0, 0, 0.84);
            --panel-border: rgba(0, 255, 255, 0.35);
            --hud-glow: 0 0 14px rgba(0, 255, 255, 0.35), 0 0 32px rgba(0, 255, 255, 0.18);
        }

        /* Subtle page-wide neon ambience */
        body::before {
            content: "";
            position: fixed;
            inset: 0;
            background:
                radial-gradient(1200px 800px at 30% 10%, rgba(0,255,255,0.06), transparent 60%),
                radial-gradient(1000px 700px at 70% 80%, rgba(255,0,255,0.05), transparent 60%);
            pointer-events: none;
            z-index: 0;
            mix-blend-mode: screen;
        }

        body {
            margin: 0;
            padding: 20px;
            background: #0a0a0a;
            color: var(--neon-cyan);
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; /* for pseudo elements */
            z-index: 0; /* ensure stacking behind UI */
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            position: relative;
            z-index: 2;
        }
        #canvas-border {
            border: 2px solid var(--neon-cyan);
            box-shadow:
                0 0 20px rgba(0, 255, 255, 0.3),
                inset 0 0 32px rgba(0, 255, 255, 0.06);
        }

        /* Upgraded UI panel with a neon chassis look */
        .ui-panel {
            width: 800px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            padding: 12px;
            border-radius: 8px;
            background:
                linear-gradient(180deg, rgba(0, 20, 25, 0.85), rgba(0, 0, 0, 0.9)),
                radial-gradient(600px 140px at 50% -60%, rgba(0,255,255,0.08), transparent 70%);
            border: 1px solid var(--panel-border);
            box-shadow:
                0 0 24px rgba(0, 255, 255, 0.18),
                inset 0 0 18px rgba(0, 255, 255, 0.08);
            position: relative;
            z-index: 3;
        }
        .ui-panel::before {
            content: "";
            position: absolute;
            inset: -2px;
            border-radius: 10px;
            background: linear-gradient(45deg, rgba(0,255,255,0.15), rgba(255,0,255,0.12));
            filter: blur(6px);
            z-index: -1;
            opacity: 0.7;
        }

        .ui-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* Health bar: keep width/height but enhance graphics */
        .health-bar {
            width: 200px;     /* unchanged size constraint */
            height: 20px;     /* unchanged size constraint */
            position: relative;
            border: 1px solid #ff0044;
            background:
                linear-gradient(90deg,
                    rgba(60, 0, 0, 0.9),
                    rgba(30, 0, 0, 0.95) 40%,
                    rgba(10, 0, 0, 0.98)
                );
            border-radius: 5px;
            overflow: hidden;
            box-shadow:
                inset 0 0 8px rgba(255, 0, 68, 0.35),
                0 0 10px rgba(255, 0, 68, 0.2);
        }
        .health-bar::after {
            content: "";
            position: absolute;
            inset: 0;
            background-image: repeating-linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.06) 0px,
                rgba(255, 255, 255, 0.06) 6px,
                transparent 7px,
                transparent 12px
            );
            opacity: 0.25;
            mix-blend-mode: overlay;
            pointer-events: none;
        }
        .health-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff0044, #ff4444);
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow:
                inset 0 0 8px rgba(255, 136, 136, 0.85),
                0 0 8px rgba(255, 0, 68, 0.65);
        }
        /* Subtle pulse on the fill to feel "alive" */
        .health-fill::after {
            content: "";
            position: absolute;
            left: -30%;
            top: 0;
            bottom: 0;
            width: 30%;
            background: linear-gradient(
                to right,
                rgba(255,255,255,0) 0%,
                rgba(255,255,255,0.25) 50%,
                rgba(255,255,255,0) 100%
            );
            filter: blur(1px);
            pointer-events: none;
        }

        .ui-right {
            display: flex;
            align-items: center;
            gap: 18px;
        }

        .bomb-counter {
            color: var(--neon-yellow);
            text-shadow: 0 0 8px rgba(255, 255, 0, 0.5);
        }

        .power-up-display {
            color: var(--neon-pink);
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.55);
        }

        /* Vertical stack for Level + FPS (FPS under Level) */
        .level-stack {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .level-info {
            color: var(--neon-green);
            text-align: left;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.55);
        }

        /* Upgrade the FPS info with a tiny HUD glass and scanline shimmer */
        .fps-info {
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-bottom: 0;
            background:
                linear-gradient(180deg, rgba(20, 40, 45, 0.75), rgba(0, 0, 0, 0.65));
            border: 1px solid rgba(0, 255, 255, 0.35);
            box-shadow:
                inset 0 0 8px rgba(0, 255, 255, 0.15),
                0 0 12px rgba(0, 255, 255, 0.25);
            padding: 3px 6px;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            white-space: nowrap;
            line-height: 1.2;
        }
        .fps-info::after {
            content: "";
            position: absolute;
            left: 0; right: 0; top: 0; height: 100%;
            background-image: repeating-linear-gradient(
                to bottom,
                rgba(0,255,255,0.10) 0px,
                rgba(0,255,255,0.10) 1px,
                transparent 2px,
                transparent 4px
            );
            opacity: 0.35;
            pointer-events: none;
        }
        #fpsValue {
            color: var(--neon-cyan);
            text-shadow: var(--hud-glow);
        }

        /* Controls - neon styling but keep text content */
        .controls {
            width: 800px;
            margin-top: 10px;
            padding: 10px 14px;
            border-radius: 8px;
            color: #bdf6ff;
            background:
                linear-gradient(180deg, rgba(0, 20, 25, 0.75), rgba(0, 0, 0, 0.85)),
                radial-gradient(400px 120px at 15% -40%, rgba(0,255,255,0.09), transparent 60%);
            border: 1px solid rgba(0, 255, 255, 0.35);
            box-shadow:
                inset 0 0 12px rgba(0, 255, 255, 0.12),
                0 0 18px rgba(0, 255, 255, 0.22);
            position: relative;
            z-index: 2;
        }
        .controls p {
            color: #d9ffff;
            margin: 6px 0;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.45);
        }
        .license-wrapper {
            display: flex;
            justify-content: center;
            margin-top: 6px;
        }
        .license-wrapper > a {
            display: inline-block;
            padding: 6px 10px;
            color: #aaffff;
            background: linear-gradient(180deg, rgba(0,30,40,0.8), rgba(0,0,0,0.85));
            border: 1px solid rgba(0, 255, 255, 0.5);
            border-radius: 6px;
            text-decoration: none;
            letter-spacing: 0.3px;
            box-shadow:
                inset 0 0 12px rgba(0, 255, 255, 0.18),
                0 0 16px rgba(0, 255, 255, 0.28);
            transition: transform 120ms ease, box-shadow 120ms ease;
        }
        .license-wrapper > a:hover {
            transform: translateY(-1px);
            box-shadow:
                inset 0 0 14px rgba(0, 255, 255, 0.24),
                0 0 22px rgba(0, 255, 255, 0.35);
        }

        /* Whisper overlay - upgraded neon presence */
        .whisper-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background:
                linear-gradient(180deg, rgba(0, 8, 12, 0.96), rgba(0, 0, 0, 0.98)),
                radial-gradient(320px 180px at 50% 10%, rgba(0,255,255,0.15), transparent 60%);
            color: var(--neon-cyan);
            padding: 30px;
            border: 2px solid var(--neon-cyan);
            text-align: center;
            font-size: 16px;
            z-index: 1000;
            max-width: 600px;
            border-radius: 10px;
            box-shadow:
                0 0 30px rgba(0, 255, 255, 0.6),
                inset 0 0 40px rgba(0, 255, 255, 0.08);
        }
        .whisper-overlay h3 {
            margin: 0 0 12px 0;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: #e0fdff;
            text-shadow:
                0 0 12px rgba(0, 255, 255, 0.55),
                0 0 28px rgba(0, 255, 255, 0.35);
        }
        .whisper-overlay p {
            margin: 8px 0;
            color: #c7ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.45);
        }

        /* Boss health bar - enhanced visuals, same size constraints */
        .boss-health-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;    /* keep exact width */
            height: 20px;    /* keep exact height */
            border: 2px solid #ff0000;
            background:
                linear-gradient(180deg, rgba(40, 0, 0, 0.95), rgba(10, 0, 0, 0.98));
            z-index: 999;
            border-radius: 6px;
            overflow: hidden;
            box-shadow:
                inset 0 0 12px rgba(255, 0, 0, 0.35),
                0 0 14px rgba(255, 0, 0, 0.25);
        }
        .boss-health-fill {
            height: 100%;
            transition: width 0.3s ease;
            position: relative;
            background:
                linear-gradient(90deg, #ff0000, #ff4444);
            box-shadow:
                inset 0 0 10px rgba(255, 120, 120, 0.8),
                0 0 8px rgba(255, 0, 0, 0.7);
            overflow: hidden;
        }
        /* Subtle diagonal danger stripes on the boss bar fill */
        .boss-health-fill::after {
            content: "";
            position: absolute;
            inset: 0;
            background-image: repeating-linear-gradient(
                -45deg,
                rgba(255, 255, 255, 0.15) 0px,
                rgba(255, 255, 255, 0.15) 6px,
                transparent 8px,
                transparent 16px
            );
            opacity: 0.25;
            mix-blend-mode: screen;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="ui-panel">
        <div class="ui-left">
            <div>
                <div>Health:</div>
                <div class="health-bar">
                    <div class="health-fill" id="healthFill"></div>
                </div>
                <div class="bomb-counter">
                    Bombs: <span id="bombCount">0</span>/<span id="maxBombs">1</span>
                </div>
            </div>
        </div>

        <div class="ui-right">
            <div class="power-up-display">Power: <span id="powerUpInfo">None</span></div>
            <div class="level-stack">
                <div class="level-info">Level: <span id="currentLevel">1</span>/5</div>
                <div class="fps-info" id="fpsContainer">FPS: <span id="fpsValue">0</span></div>
            </div>
        </div>
    </div>

    <div id="canvas-border">
        <canvas id="gameCanvas" width="800" height="608"></canvas>
    </div>

    <div class="controls">
        <p>Arrow Keys or WASD: Move | Space: Place Bomb | X or M: Remote Detonate | R: Restart</p>
        <p>Destroy destructible walls to find power-ups! Beware of environmental hazards!</p>
        <div class="license-wrapper">
            <a href="https://www.gnu.org/licenses/agpl-3.0.en.html" target="_blank">License: AGPLv3</a>
        </div>
    </div>

    <script>
        // Core constants
        const TILE_SIZE = 32;
        const GRID_WIDTH = 25;
        const GRID_HEIGHT = 19;
        const CANVAS_WIDTH = GRID_WIDTH * TILE_SIZE;
        const CANVAS_HEIGHT = GRID_HEIGHT * TILE_SIZE;

        // Game state enum
        const GAME_STATE = {
            MENU: 'menu',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'game_over',
            VICTORY: 'victory',
            BOSS_FIGHT: 'boss_fight',
            WHISPER: 'whisper'
        };

        // Tile types
        const TILE_TYPE = {
            EMPTY: 0,
            WALL_SOLID: 1,
            WALL_DESTRUCTIBLE: 2,
            EXIT: 3,
            POWERUP: 4,
            HAZARD_STEAM: 5,
            HAZARD_CONVEYOR: 6,
            HAZARD_PLASMA: 7,
            GRAVITY_ZONE: 8
        };

        // Power-up types
        const POWERUP_TYPE = {
            FIREPOWER: 'firepower',
            MULTI_BOMB: 'multi_bomb',
            SPEED: 'speed',
            REMOTE_DETONATION: 'remote_detonation',
            PIERCING_CHARGE: 'piercing_charge',
            SHIELD_DRONE: 'shield_drone',
            KEYCARD_FRAGMENT: 'keycard_fragment'
        };

        // Enemy types
        const ENEMY_TYPE = {
            PATROL_DRONE: 'patrol_drone',
            SENTINEL_CONSTRUCT: 'sentinel_construct',
            CORROSION_DRONE: 'corrosion_drone',
            NODE_WISP: 'node_wisp', // Purple enemies - reworked
            CRYSTAL_LEECH: 'crystal_leech',
            SHIELD_BEARER: 'shield_bearer',
            GRAVITY_SKITTER: 'gravity_skitter',
            ARCHITECT_SHARD: 'architect_shard'
        };

        // Boss types
        const BOSS_TYPE = {
            SENTINEL_NODE_ALPHA: 'sentinel_node_alpha',
            WARDEN_K79: 'warden_k79',
            ARCHITECT_PRIME: 'architect_prime'
        };

        // Level themes
        const LEVEL_THEME = {
            FIRST_GATE: 'first_gate',
            ECHO_VAULT: 'echo_vault',
            FRACTURE_MINES: 'fracture_mines',
            SYNTHESIS_SPIRE: 'synthesis_spire',
            ARCHITECTS_LOOM: 'architects_loom'
        };

        // Utility functions
        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }

        // Enhanced Audio System
        class AudioSystem {
            constructor() {
                this.audioContext = null;
                this.masterVolume = 0.3;
                this.musicGain = null;
                this.sfxGain = null;
                this.init();
            }

            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Create gain nodes for mixing
                    this.musicGain = this.audioContext.createGain();
                    this.sfxGain = this.audioContext.createGain();
                    this.masterGain = this.audioContext.createGain();

                    this.musicGain.connect(this.masterGain);
                    this.sfxGain.connect(this.masterGain);
                    this.masterGain.connect(this.audioContext.destination);

                    this.masterGain.gain.setValueAtTime(this.masterVolume, this.audioContext.currentTime);
                } catch (e) {
                    console.warn('Web Audio not supported');
                }
            }

            createOscillator(frequency, type = 'sine') {
                if (!this.audioContext) return null;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);

                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);

                return { oscillator, gainNode };
            }

            playBombExplosion() {
                if (!this.audioContext) return;

                try {
                    // Multi-layered explosion sound
                    const bufferSize = this.audioContext.sampleRate * 0.8;
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const data = buffer.getChannelData(0);

                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.4));
                    }

                    const source = this.audioContext.createBufferSource();
                    const gainNode = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();

                    source.buffer = buffer;
                    source.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.sfxGain);

                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.8);

                    gainNode.gain.setValueAtTime(this.masterVolume * 2.0, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.8);

                    source.start();
                } catch (e) {
                    console.warn('Error playing bomb explosion:', e);
                }
            }

            playPowerUpPickup() {
                if (!this.audioContext) return;

                try {
                    const { oscillator, gainNode } = this.createOscillator(440, 'square');
                    gainNode.gain.setValueAtTime(this.masterVolume * 0.4, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);

                    oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1320, this.audioContext.currentTime + 0.4);

                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                } catch (e) {
                    console.warn('Error playing power-up pickup:', e);
                }
            }

            playEnemyDeath() {
                if (!this.audioContext) return;

                try {
                    const { oscillator, gainNode } = this.createOscillator(300, 'sawtooth');
                    gainNode.gain.setValueAtTime(this.masterVolume * 0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);

                    oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.3);

                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + 0.3);
                } catch (e) {
                    console.warn('Error playing enemy death:', e);
                }
            }

            playBossTheme() {
                if (!this.audioContext) return;

                try {
                    // Create a simple boss theme
                    const notes = [220, 277, 330, 440]; // A, C#, E, A
                    let time = this.audioContext.currentTime;

                    notes.forEach((freq, index) => {
                        const { oscillator, gainNode } = this.createOscillator(freq, 'square');
                        gainNode.gain.setValueAtTime(0, time);
                        gainNode.gain.linearRampToValueAtTime(this.masterVolume * 0.2, time + 0.1);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, time + 0.8);

                        oscillator.start(time);
                        oscillator.stop(time + 0.8);
                        time += 0.2;
                    });
                } catch (e) {
                    console.warn('Error playing boss theme:', e);
                }
            }

            playWhisperSound() {
                if (!this.audioContext) return;

                try {
                    const bufferSize = this.audioContext.sampleRate * 2;
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const data = buffer.getChannelData(0);

                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.sin(i * 0.01) * Math.random() * 0.1;
                    }

                    const source = this.audioContext.createBufferSource();
                    const gainNode = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();

                    source.buffer = buffer;
                    source.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.sfxGain);

                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    filter.Q.setValueAtTime(5, this.audioContext.currentTime);

                    gainNode.gain.setValueAtTime(this.masterVolume * 0.2, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 2);

                    source.start();
                } catch (e) {
                    console.warn('Error playing whisper:', e);
                }
            }
        }

        // Enhanced Input System
        class InputSystem {
            constructor() {
                this.keys = new Set();
                this.keyPressed = new Set();
                this.mousePosition = { x: 0, y: 0 };
                // Keys that cause page scroll we want to handle ourselves
                this._preventDefaultCodes = new Set([
                    'Space',
                    'ArrowUp',
                    'ArrowDown',
                    'ArrowLeft',
                    'ArrowRight'
                ]);
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    // Block browser scroll/hyperkey behavior when we intend to use the key
                    if (this._preventDefaultCodes.has(e.code)) {
                        e.preventDefault();
                    }

                    if (!this.keys.has(e.code)) {
                        this.keyPressed.add(e.code);
                    }
                    this.keys.add(e.code);
                });

                document.addEventListener('keyup', (e) => {
                    this.keys.delete(e.code);
                });

                document.addEventListener('mousemove', (e) => {
                    const rect = document.getElementById('gameCanvas').getBoundingClientRect();
                    this.mousePosition.x = e.clientX - rect.left;
                    this.mousePosition.y = e.clientY - rect.top;
                });
            }

            isKeyPressed(keyCode) {
                return this.keyPressed.has(keyCode);
            }

            isKeyDown(keyCode) {
                return this.keys.has(keyCode);
            }

            consumeKeyPress(keyCode) {
                this.keyPressed.delete(keyCode);
            }

            getMousePosition() {
                return { ...this.mousePosition };
            }

            update() {
                this.keyPressed.clear();
            }
        }

        // Enhanced Level Generator
        class LevelGenerator {
            static generateLevel(levelNumber) {
                const theme = this.getLevelTheme(levelNumber);
                const grid = [];

                // Initialize grid with maze pattern
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    grid[y] = [];
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        if (x === 0 || x === GRID_WIDTH - 1 || y === 0 || y === GRID_HEIGHT - 1) {
                            grid[y][x] = TILE_TYPE.WALL_SOLID;
                        } else if (x % 2 === 0 && y % 2 === 0) {
                            grid[y][x] = TILE_TYPE.WALL_SOLID;
                        } else {
                            grid[y][x] = TILE_TYPE.EMPTY;
                        }
                    }
                }

                // Add destructible walls based on level
                const destructibleDensity = 0.5 + (levelNumber * 0.1);
                for (let y = 1; y < GRID_HEIGHT - 1; y++) {
                    for (let x = 1; x < GRID_WIDTH - 1; x++) {
                        if (grid[y][x] === TILE_TYPE.EMPTY && Math.random() < destructibleDensity) {
                            grid[y][x] = TILE_TYPE.WALL_DESTRUCTIBLE;
                        }
                    }
                }

                // Ensure start area is clear
                const startX = 1, startY = 1;
                this.clearArea(grid, startX, startY, 3, 3);

                // Place exit
                const exitX = GRID_WIDTH - 2;
                const exitY = GRID_HEIGHT - 2;

                // Create guaranteed path to exit with specified number of paths
                const pathCount = Math.max(1, 6 - levelNumber);
                this.createMultiplePathsToExit(grid, { x: startX, y: startY }, { x: exitX, y: exitY }, pathCount);

                // Add environmental hazards based on theme
                this.addEnvironmentalHazards(grid, theme, levelNumber);

                // Place power-ups
                this.placePowerUps(grid, levelNumber);

                // Place boss if applicable
                let bossData = null;
                if (levelNumber === 1) {
                    bossData = this.placeMiniBoss(grid, 'Sentinel Node Alpha');
                } else if (levelNumber === 3) {
                    bossData = this.placeBoss(grid, 'Warden K-79');
                } else if (levelNumber === 5) {
                    bossData = this.placeBoss(grid, 'The Architect Prime');
                }

                return {
                    grid,
                    theme,
                    startPosition: { x: startX * TILE_SIZE + TILE_SIZE / 2, y: startY * TILE_SIZE + TILE_SIZE / 2 },
                    exitPosition: { x: exitX, y: exitY },
                    bossData
                };
            }

            static getLevelTheme(levelNumber) {
                const themes = [
                    LEVEL_THEME.FIRST_GATE,
                    LEVEL_THEME.ECHO_VAULT,
                    LEVEL_THEME.FRACTURE_MINES,
                    LEVEL_THEME.SYNTHESIS_SPIRE,
                    LEVEL_THEME.ARCHITECTS_LOOM
                ];
                return themes[levelNumber - 1] || LEVEL_THEME.FIRST_GATE;
            }

            static clearArea(grid, startX, startY, width, height) {
                for (let y = startY; y < startY + height; y++) {
                    for (let x = startX; x < startX + width; x++) {
                        if (y < GRID_HEIGHT && x < GRID_WIDTH) {
                            grid[y][x] = TILE_TYPE.EMPTY;
                        }
                    }
                }
            }

            static createMultiplePathsToExit(grid, start, end, pathCount) {
                for (let i = 0; i < pathCount; i++) {
                    this.createPathToExit(grid, start, end, i * 0.2);
                }

                // Ensure exit is accessible
                grid[end.y][end.x] = TILE_TYPE.EXIT;
            }

            static createPathToExit(grid, start, end, offset = 0) {
                let current = { ...start };

                while (current.x !== end.x || current.y !== end.y) {
                    grid[current.y][current.x] = TILE_TYPE.EMPTY;

                    // Move towards exit with some randomness and offset
                    const rand = Math.random() + offset;
                    if (current.x < end.x && rand < 0.7) {
                        current.x++;
                    } else if (current.y < end.y && rand < 0.7) {
                        current.y++;
                    } else if (current.x < end.x) {
                        current.x++;
                    } else {
                        current.y++;
                    }

                    // Ensure we don't go out of bounds
                    current.x = clamp(current.x, 1, GRID_WIDTH - 2);
                    current.y = clamp(current.y, 1, GRID_HEIGHT - 2);
                }
            }

            static addEnvironmentalHazards(grid, theme, levelNumber) {
                const hazardCount = Math.min(10, levelNumber * 2);

                for (let i = 0; i < hazardCount; i++) {
                    const x = randomInt(2, GRID_WIDTH - 3);
                    const y = randomInt(2, GRID_HEIGHT - 3);

                    if (grid[y][x] === TILE_TYPE.EMPTY) {
                        let hazardType;

                        switch (theme) {
                            case LEVEL_THEME.FRACTURE_MINES:
                                hazardType = Math.random() < 0.5 ? TILE_TYPE.HAZARD_CONVEYOR : TILE_TYPE.HAZARD_STEAM;
                                break;
                            case LEVEL_THEME.SYNTHESIS_SPIRE:
                                hazardType = Math.random() < 0.7 ? TILE_TYPE.GRAVITY_ZONE : TILE_TYPE.HAZARD_PLASMA;
                                break;
                            case LEVEL_THEME.ARCHITECTS_LOOM:
                                hazardType = Math.random() < 0.6 ? TILE_TYPE.GRAVITY_ZONE : TILE_TYPE.HAZARD_PLASMA;
                                break;
                            default:
                                hazardType = TILE_TYPE.HAZARD_STEAM;
                        }

                        grid[y][x] = hazardType;
                    }
                }
            }

            static placePowerUps(grid, levelNumber) {
                const powerUpCount = Math.min(8, 3 + levelNumber);
                let placed = 0;
                let attempts = 0;

                while (placed < powerUpCount && attempts < 200) {
                    const x = randomInt(1, GRID_WIDTH - 2);
                    const y = randomInt(1, GRID_HEIGHT - 2);
                    attempts++;

                    if (grid[y][x] === TILE_TYPE.WALL_DESTRUCTIBLE &&
                        distance(x, y, 1, 1) > 4 &&
                        distance(x, y, GRID_WIDTH - 2, GRID_HEIGHT - 2) > 4) {

                        grid[y][x] = TILE_TYPE.POWERUP;
                        placed++;
                    }
                }
            }

            static placeMiniBoss(grid, bossName) {
                // Place mini-boss in a cleared arena
                const centerX = Math.floor(GRID_WIDTH / 2);
                const centerY = Math.floor(GRID_HEIGHT / 2);

                this.clearArea(grid, centerX - 2, centerY - 2, 5, 5);

                return {
                    type: BOSS_TYPE.SENTINEL_NODE_ALPHA,
                    position: { x: centerX * TILE_SIZE + TILE_SIZE / 2, y: centerY * TILE_SIZE + TILE_SIZE / 2 },
                    health: 10,
                    maxHealth: 10
                };
            }

            static placeBoss(grid, bossName) {
                // Create boss arena
                const centerX = Math.floor(GRID_WIDTH / 2);
                const centerY = Math.floor(GRID_HEIGHT / 2);

                this.clearArea(grid, centerX - 3, centerY - 3, 7, 7);

                let bossType, health;
                switch (bossName) {
                    case 'Warden K-79':
                        bossType = BOSS_TYPE.WARDEN_K79;
                        health = 20;
                        break;
                    case 'The Architect Prime':
                        bossType = BOSS_TYPE.ARCHITECT_PRIME;
                        health = 40;
                        break;
                    default:
                        bossType = BOSS_TYPE.SENTINEL_NODE_ALPHA;
                        health = 20;
                }

                return {
                    type: bossType,
                    position: { x: centerX * TILE_SIZE + TILE_SIZE / 2, y: centerY * TILE_SIZE + TILE_SIZE / 2 },
                    health,
                    maxHealth: health
                };
            }
        }

        // Enhanced Entity System
        class Entity {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.vx = 0;
                this.vy = 0;
                this.active = true;
                this.animationTime = 0;
            }

            getBounds() {
                return {
                    left: this.x - this.width / 2,
                    right: this.x + this.width / 2,
                    top: this.y - this.height / 2,
                    bottom: this.y + this.height / 2
                };
            }

            intersects(other) {
                const bounds1 = this.getBounds();
                const bounds2 = other.getBounds();

                return !(bounds1.right < bounds2.left ||
                        bounds1.left > bounds2.right ||
                        bounds1.bottom < bounds2.top ||
                        bounds1.top > bounds2.bottom);
            }

            updateAnimation(deltaTime) {
                this.animationTime += deltaTime;
            }

            // Axis-separated movement to avoid "corner tunneling" through walls.
            moveWithCollisions(grid, dt) {
                const newX = this.x + this.vx * dt;
                if (!this.checkCollision(newX, this.y, grid)) {
                    this.x = newX;
                } else {
                    // Stop horizontal motion when colliding
                    this.vx = 0;
                }

                const newY = this.y + this.vy * dt;
                if (!this.checkCollision(this.x, newY, grid)) {
                    this.y = newY;
                } else {
                    // Stop vertical motion when colliding
                    this.vy = 0;
                }
            }
        }

        class Player extends Entity {
            constructor(x, y) {
                super(x, y, 24, 24);
                this.baseSpeed = 240; // pixels/second (was 2 px/frame)
                this.speed = this.baseSpeed;
                this.health = 100;
                this.maxHealth = 100;
                this.bombs = []; // bombs currently placed by the player (not all bombs on map)
                this.maxBombs = 1;
                this.baseBombRadius = 2;
                this.bombRadius = this.baseBombRadius;
                this.invulnerable = false;
                this.invulnerabilityDuration = 1.0; // seconds
                this.invulnerabilityTimer = 0; // seconds
                this.remoteDetonation = false;
                this.piercingCharges = false;
                this.shieldDrones = []; // Allow multiple shield drones (cap at 3 for performance)
                this.keycardFragments = 0;
                this.gravityInverted = false;
                this.gravityTimer = 0; // seconds remaining
                // Reality distortion speed handling
                this.distortionSlowTimer = 0; // seconds remaining to restore speed if slowed by effects
            }

            update(inputSystem, game, dt) {
                // Movement
                let dx = 0, dy = 0;

                if (inputSystem.isKeyDown('KeyW') || inputSystem.isKeyDown('ArrowUp')) dy -= 1;
                if (inputSystem.isKeyDown('KeyS') || inputSystem.isKeyDown('ArrowDown')) dy += 1;
                if (inputSystem.isKeyDown('KeyA') || inputSystem.isKeyDown('ArrowLeft')) dx -= 1;
                if (inputSystem.isKeyDown('KeyD') || inputSystem.isKeyDown('ArrowRight')) dx += 1;

                // Handle gravity inversion
                if (this.gravityInverted) {
                    dy = -dy;
                }

                // Normalize diagonal movement
                if (dx !== 0 && dy !== 0) {
                    dx *= 0.707;
                    dy *= 0.707;
                }

                this.vx = dx * this.speed;
                this.vy = dy * this.speed;

                // Update position with collision detection
                this.moveWithCollisions(game.level.grid, dt);

                // Check hazards for damage/effects (hazard tiles do not block)
                this.checkHazardDamage(game, dt);

                // Place bomb
                if (inputSystem.isKeyPressed('Space')) {
                    this.placeBomb(game);
                    inputSystem.consumeKeyPress('Space');
                }

                // Remote detonation: explode all bombs immediately
                if (this.remoteDetonation) {
                    if (inputSystem.isKeyPressed('KeyX') || inputSystem.isKeyPressed('KeyM')) {
                        this.detonateRemoteBombs(game);
                        inputSystem.consumeKeyPress('KeyX');
                        inputSystem.consumeKeyPress('KeyM');
                    }
                }

                // Update invulnerability
                if (this.invulnerable) {
                    this.invulnerabilityTimer -= dt;
                    if (this.invulnerabilityTimer <= 0) {
                        this.invulnerable = false;
                    }
                }

                // Update gravity inversion
                if (this.gravityInverted) {
                    this.gravityTimer -= dt;
                    if (this.gravityTimer <= 0) {
                        this.gravityInverted = false;
                    }
                }

                // FIX: restore speed when not inside a distortion field
                if (this.distortionSlowTimer > 0) {
                    this.distortionSlowTimer -= dt;
                } else if (this.speed < this.baseSpeed) {
                    // Smoothly restore to at least baseSpeed
                    this.speed = Math.min(this.baseSpeed, this.speed + 60 * dt);
                }

                this.updateShieldDrones(game, dt);

                this.updateAnimation(dt);
            }

            updateShieldDrones(game, dt) {
                let shieldDrones = Array.from(this.shieldDrones);
                const n = this.shieldDrones.length;
                if (n === 0) return;

                const orbitRadius = Math.min(24 + n * 2, 42);
                const orbitSpeed = 2.0; // radians/sec
                const baseAngle = this.animationTime * orbitSpeed;

                for (let i = 0; i < n; i++) {
                    const drone = shieldDrones[i];
                    const angle = baseAngle + i * (Math.PI * 2 / n);
                    drone.x = game.player.x + Math.cos(angle) * orbitRadius;
                    drone.y = game.player.y + Math.sin(angle) * orbitRadius;
                    drone.update(game, dt);
                }
                this.shieldDrones = this.shieldDrones.filter(drone => drone.active);
            }

            // Hazards do not block movement; only apply effects/damage.
            checkHazardDamage(game, dt) {
                const tileX = Math.floor(this.x / TILE_SIZE);
                const tileY = Math.floor(this.y / TILE_SIZE);

                if (tileY >= 0 && tileY < GRID_HEIGHT && tileX >= 0 && tileX < GRID_WIDTH) {
                    const tileType = game.level.grid[tileY][tileX];

                    switch (tileType) {
                        case TILE_TYPE.HAZARD_STEAM:
                            if (Math.random() < 0.1 * dt * 60) { // scaled to seconds
                                this.takeDamage(5);
                            }
                            break;
                        case TILE_TYPE.HAZARD_PLASMA:
                            if (Math.random() < 0.2 * dt * 60) {
                                this.takeDamage(10);
                            }
                            break;
                        case TILE_TYPE.GRAVITY_ZONE:
                            if (!this.gravityInverted && Math.random() < 0.05 * dt * 60) {
                                this.gravityInverted = true;
                                this.gravityTimer = 5; // 5 seconds
                            }
                            break;
                    }
                }
            }

            checkCollision(x, y, grid) {
                const bounds = {
                    left: x - this.width / 2,
                    right: x + this.width / 2,
                    top: y - this.height / 2,
                    bottom: y + this.height / 2
                };

                const minTileX = Math.floor(bounds.left / TILE_SIZE);
                const maxTileX = Math.floor(bounds.right / TILE_SIZE);
                const minTileY = Math.floor(bounds.top / TILE_SIZE);
                const maxTileY = Math.floor(bounds.bottom / TILE_SIZE);

                for (let ty = minTileY; ty <= maxTileY; ty++) {
                    for (let tx = minTileX; tx <= maxTileX; tx++) {
                        if (ty >= 0 && ty < GRID_HEIGHT && tx >= 0 && tx < GRID_WIDTH) {
                            const tileType = grid[ty][tx];
                            // Hazards are pass-through for the player
                            if (tileType === TILE_TYPE.WALL_SOLID ||
                                tileType === TILE_TYPE.WALL_DESTRUCTIBLE ||
                                tileType === TILE_TYPE.POWERUP) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            placeBomb(game) {
                if (this.bombs.length >= this.maxBombs) return;

                const tileX = Math.floor(this.x / TILE_SIZE);
                const tileY = Math.floor(this.y / TILE_SIZE);

                // Check if there's already a bomb on this tile
                for (let bomb of game.bombs) {
                    const bombTileX = Math.floor(bomb.x / TILE_SIZE);
                    const bombTileY = Math.floor(bomb.y / TILE_SIZE);
                    if (bombTileX === tileX && bombTileY === tileY) {
                        return;
                    }
                }

                const bomb = new Bomb(tileX * TILE_SIZE + TILE_SIZE / 2, tileY * TILE_SIZE + TILE_SIZE / 2, this.bombRadius, this.piercingCharges);
                game.bombs.push(bomb);
                this.bombs.push(bomb); // track only player's bombs for remote detonation and UI
            }

            detonateRemoteBombs(game) {
                // Immediately detonate all of the player's bombs
                let bombs = Array.from(this.bombs);
                for (let i = 0; i < bombs.length; i++) {
                    const bomb = bombs[i];
                    if (bomb && bomb.active && !bomb.exploded) {
                        bomb.explode(game); // triggers effects, sound, damage, and marks inactive
                    }
                }
                // After manual detonation, clear the local list since all placed bombs have exploded.
                this.bombs = [];
            }

            takeDamage(amount) {
                if (!this.invulnerable) {
                    this.health -= amount;
                    this.invulnerable = true;
                    this.invulnerabilityTimer = this.invulnerabilityDuration;

                    if (this.health <= 0) {
                        this.health = 0;
                        this.active = false;
                    }
                }
            }

            applyPowerUp(type) {
                switch (type) {
                    case POWERUP_TYPE.FIREPOWER:
                        this.bombRadius = Math.min(this.bombRadius + 1, 6);
                        break;
                    case POWERUP_TYPE.MULTI_BOMB:
                        this.maxBombs = Math.min(this.maxBombs + 1, 8);
                        break;
                    case POWERUP_TYPE.SPEED:
                        // Keep upgrades additive but clamped by cap in update()
                        this.speed = clamp(this.speed + 20, this.baseSpeed, 320);
                        break;
                    case POWERUP_TYPE.REMOTE_DETONATION:
                        this.remoteDetonation = true;
                        break;
                    case POWERUP_TYPE.PIERCING_CHARGE:
                        this.piercingCharges = true;
                        break;
                    case POWERUP_TYPE.SHIELD_DRONE:
                        this.shieldDrones = this.shieldDrones.filter(drone => drone.active);
                        if (this.shieldDrones.length < 5) {
                            const drone = new ShieldDrone(this.x, this.y, this.shieldDrones.length);
                            this.shieldDrones.push(drone);
                        }
                        break;
                    case POWERUP_TYPE.KEYCARD_FRAGMENT:
                        this.keycardFragments++;
                        break;
                }
            }

            // Reset to base stats (used on level restart)
            resetToBase() {
                this.speed = this.baseSpeed;
                this.maxBombs = 1;
                this.bombs = []; // clear placed bombs list
                this.bombRadius = this.baseBombRadius;
                this.invulnerable = false;
                this.invulnerabilityDuration = 1.0;
                this.invulnerabilityTimer = 0;
                this.remoteDetonation = false;
                this.piercingCharges = false;
                for (const d of this.shieldDrones) d.active = false;
                this.shieldDrones = [];
                this.keycardFragments = 0;
                this.gravityInverted = false;
                this.gravityTimer = 0;
                this.distortionSlowTimer = 0;
                this.health = this.maxHealth;
            }

            render(ctx) {
                ctx.save();

                ctx.globalAlpha = 1;
                if (this.invulnerable && Math.floor(Date.now() / 100) % 2) {
                    ctx.globalAlpha = 0.5;
                }

                // Shadow on the floor
                ctx.fillStyle = 'rgba(0,0,0,0.35)';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y + 12, 10, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Torso
                ctx.fillStyle = '#00d7ff';
                roundedRect(ctx, this.x - 10, this.y - 14, 20, 22, 4);

                // Shoulder pads
                ctx.fillStyle = '#00a8cc';
                roundedRect(ctx, this.x - 14, this.y - 18, 7, 10, 2);
                roundedRect(ctx, this.x + 7, this.y - 18, 7, 10, 2);

                // Chest plate accent lines
                ctx.strokeStyle = '#66f2ff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(this.x - 6, this.y - 8); ctx.lineTo(this.x + 6, this.y - 8);
                ctx.moveTo(this.x - 8, this.y - 2); ctx.lineTo(this.x + 8, this.y - 2);
                ctx.moveTo(this.x - 6, this.y + 4); ctx.lineTo(this.x + 6, this.y + 4);
                ctx.stroke();

                // Visor (helmet)
                const visorGradient = ctx.createLinearGradient(this.x - 9, this.y - 10, this.x + 9, this.y - 10);
                visorGradient.addColorStop(0, '#0077aa');
                visorGradient.addColorStop(1, '#00bbee');
                ctx.fillStyle = visorGradient;
                roundedRect(ctx, this.x - 9, this.y - 10, 18, 9, 3);

                // Visor scanline glow
                ctx.strokeStyle = 'rgba(0,255,255,0.7)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(this.x - 8, this.y - 6);
                ctx.lineTo(this.x + 8, this.y - 6);
                ctx.stroke();

                // Gloves
                ctx.fillStyle = '#008fb3';
                roundedRect(ctx, this.x - 14, this.y - 2, 6, 6, 2);
                roundedRect(ctx, this.x + 8, this.y - 2, 6, 6, 2);

                // Utility belt
                ctx.fillStyle = '#004d66';
                ctx.fillRect(this.x - 10, this.y + 2, 20, 4);
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(this.x - 3, this.y + 1, 6, 6);

                // Legs
                ctx.fillStyle = '#0099cc';
                roundedRect(ctx, this.x - 6, this.y + 8, 5, 6, 2);
                roundedRect(ctx, this.x + 1, this.y + 8, 5, 6, 2);

                // Boots
                ctx.fillStyle = '#006699';
                roundedRect(ctx, this.x - 7, this.y + 13, 7, 4, 2);
                roundedRect(ctx, this.x + 1, this.y + 13, 7, 4, 2);

                // Shoulder vents with particle hints based on speed
                const ventPhase = (this.animationTime * 6) % (Math.PI * 2);
                const ventIntensity = clamp((this.speed - this.baseSpeed) / 80, 0, 1) * 0.7 + 0.2;
                ctx.fillStyle = `rgba(0,255,255,${ventIntensity})`;
                ctx.beginPath();
                ctx.arc(this.x - 11, this.y - 14, 2 + Math.sin(ventPhase)*1.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(this.x + 11, this.y - 14, 2 + Math.cos(ventPhase)*1.2, 0, Math.PI * 2);
                ctx.fill();

                // Gravity inversion effect ring
                if (this.gravityInverted) {
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([4, 3]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Draw shield drones (draw at full opacity to avoid accidental dim)
                for (const drone of this.shieldDrones) {
                    drone.render(ctx);
                }

                ctx.restore();
            }
        }

        class ShieldDrone extends Entity {
            constructor(x, y, index) {
                super(x, y, 8, 8);
                this.health = 5;
                this.maxHealth = 5;
            }

            update(game, dt) {
                // Position set by Player.updateShieldDrones each frame
                // Check for enemy projectiles
                for (let projectile of game.projectiles) {
                    if (this.intersects(projectile)) {
                        projectile.active = false;
                        this.health--;
                        if (this.health <= 0) {
                            this.active = false;
                        }
                    }
                }
            }

            render(ctx) {
                ctx.save();

                // Shield core
                ctx.fillStyle = '#fff066';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                ctx.fill();

                // Rotating ring segments to suggest orbit
                const t = Date.now() * 0.005 + (this.health % 5);
                ctx.strokeStyle = '#ffee44';
                ctx.lineWidth = 2;
                for (let i = 0; i < 4; i++) {
                    const a0 = t + i * Math.PI / 2;
                    const a1 = a0 + Math.PI / 6;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 8, a0, a1);
                    ctx.stroke();
                }

                // Glow
                ctx.shadowColor = '#ffee44';
                ctx.shadowBlur = 6;
                ctx.strokeStyle = '#fff3a1';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }
        }

        class Enemy extends Entity {
            constructor(x, y, type) {
                super(x, y, 20, 20);
                this.type = type;
                this.setupEnemyStats();
                this.direction = { x: 1, y: 0 };
                this.changeDirectionTimer = 0; // seconds
                this.target = null;
                this.attackCooldown = 0; // seconds
                this.acidSprayTimer = 0; // seconds
                this.shieldRotation = 0;
                this.gravityField = null;

                // Reworked Purple enemy timers (Node Wisp)
                this.phaseShiftCooldown = 2.5; // seconds between teleports
                this.phaseShiftTimer = 1.25; // seconds until next teleport
                this.vulnerabilityWindow = 0.8; // seconds when it's fully tangible and slow
                this.vulnerabilityTimer = 0; // seconds remaining of vulnerability
            }

            setupEnemyStats() {
                switch (this.type) {
                    case ENEMY_TYPE.PATROL_DRONE:
                        this.speed = 60; // px/s
                        this.health = 1;
                        this.detectionRange = 100;
                        break;
                    case ENEMY_TYPE.SENTINEL_CONSTRUCT:
                        this.speed = 30;
                        this.health = 3;
                        this.detectionRange = 120;
                        break;
                    case ENEMY_TYPE.CORROSION_DRONE:
                        this.speed = 48;
                        this.health = 2;
                        this.detectionRange = 80;
                        this.acidDamage = 1;
                        break;
                    case ENEMY_TYPE.NODE_WISP: // Purple enemy - reworked to be much weaker
                        this.speed = 20;   // base move speed
                        this.health = 1;   // now one hit kills with bombs; weak against all attacks
                        this.detectionRange = 60;
                        break;
                    case ENEMY_TYPE.CRYSTAL_LEECH:
                        this.speed = 36;
                        this.health = 2;
                        this.detectionRange = 90;
                        break;
                    case ENEMY_TYPE.SHIELD_BEARER:
                        this.speed = 24;
                        this.health = 4;
                        this.detectionRange = 100;
                        this.shieldActive = true;
                        break;
                    case ENEMY_TYPE.GRAVITY_SKITTER:
                        this.speed = 66;
                        this.health = 2;
                        this.detectionRange = 70;
                        break;
                    case ENEMY_TYPE.ARCHITECT_SHARD:
                        this.speed = 54;
                        this.health = 1;
                        this.detectionRange = 150;
                        break;
                }

                this.maxHealth = this.health;
            }

            update(game, dt) {
                this.changeDirectionTimer -= dt;
                this.attackCooldown -= dt;
                this.acidSprayTimer -= dt;

                if (this.changeDirectionTimer <= 0) {
                    this.changeDirection(game);
                    this.changeDirectionTimer = randomInt(60, 180) / 60; // seconds
                }

                // Update type-specific behavior
                switch (this.type) {
                    case ENEMY_TYPE.NODE_WISP:
                        this.updateNodeWisp(game, dt);
                        break;
                    case ENEMY_TYPE.CRYSTAL_LEECH:
                        this.updateCrystalLeech(game, dt);
                        break;
                    case ENEMY_TYPE.SHIELD_BEARER:
                        this.updateShieldBearer(game, dt);
                        break;
                    case ENEMY_TYPE.GRAVITY_SKITTER:
                        this.updateGravitySkitter(game, dt);
                        break;
                    case ENEMY_TYPE.CORROSION_DRONE:
                        this.updateCorrosionDrone(game, dt);
                        break;
                    default:
                        this.updateBasicAI(game, dt);
                }

                // Check collision with player and mark as attacker for highlighting
                if (game.player && this.intersects(game.player)) {
                    game.player.takeDamage(10);
                    game.markEnemyAsAttacker(this);
                }

                this.updateAnimation(dt);
            }

            updateBasicAI(game, dt) {
                const newX = this.x + this.direction.x * this.speed * dt;
                const newY = this.y + this.direction.y * this.speed * dt;

                if (!this.checkCollision(newX, newY, game.level.grid)) {
                    this.x = newX;
                    this.y = newY;
                } else {
                    this.changeDirection();
                }
            }

            updateNodeWisp(game, dt) {
                // Reworked purple enemy behavior:
                // - Teleport near the player every ~2.5s.
                // - After teleport: 0.8s vulnerability window (slower movement).
                // - Outside vulnerability: faster but still killable; damage reduced to 6 per hit.
                this.phaseShiftTimer -= dt;
                this.vulnerabilityTimer -= dt;

                if (this.phaseShiftTimer <= 0) {
                    this.phaseShiftTimer = this.phaseShiftCooldown;
                    this.vulnerabilityTimer = this.vulnerabilityWindow;

                    // Teleport closer to the player but not inside walls and not exactly on player
                    const pos = this.findValidTeleportPosition(game, game.player.x, game.player.y, 4);
                    if (pos) {
                        this.x = pos.x;
                        this.y = pos.y;
                    }
                }

                // Movement towards the player with reduced speed during vulnerability
                const dx = game.player.x - this.x;
                const dy = game.player.y - this.y;
                const dist = Math.hypot(dx, dy) || 1;
                let speed = this.speed;

                if (this.vulnerabilityTimer > 0) {
                    speed *= 0.5; // slow down while vulnerable
                }

                this.vx = (dx / dist) * speed;
                this.vy = (dy / dist) * speed;

                this.moveWithCollisions(game.level.grid, dt);
            }

            updateCrystalLeech(game, dt) {
                // Burrow through destructible walls
                const aheadX = this.x + this.direction.x * 16;
                const aheadY = this.y + this.direction.y * 16;
                const tileX = Math.floor(aheadX / TILE_SIZE);
                const tileY = Math.floor(aheadY / TILE_SIZE);

                if (game.level.grid[tileY] && game.level.grid[tileY][tileX] === TILE_TYPE.WALL_DESTRUCTIBLE) {
                    game.level.grid[tileY][tileX] = TILE_TYPE.EMPTY;
                }

                this.updateBasicAI(game, dt);
            }

            updateShieldBearer(game, dt) {
                this.shieldRotation += 3.0 * dt; // radians/sec

                // Shield blocks attacks during certain angles
                const shieldAngle = (this.shieldRotation % (Math.PI * 2)) / (Math.PI * 2);
                this.shieldActive = shieldAngle < 0.7; // Shield active 70% of the time

                this.updateBasicAI(game, dt);
            }

            updateGravitySkitter(game, dt) {
                // Move along walls and ceiling
                if (Math.random() < 0.02 * dt * 60) { // scaled probability to seconds
                    // Attach to wall
                    const directions = [
                        { x: 0, y: -1 }, // ceiling
                        { x: 0, y: 1 },  // floor
                        { x: -1, y: 0 }, // left wall
                        { x: 1, y: 0 }   // right wall
                    ];

                    for (let dir of directions) {
                        const checkX = this.x + dir.x * 16;
                        const checkY = this.y + dir.y * 16;

                        if (!this.checkCollision(checkX, checkY, game.level.grid)) {
                            this.direction = { x: -dir.y, y: dir.x }; // Perpendicular movement
                            break;
                        }
                    }
                }

                this.updateBasicAI(game, dt);
            }

            updateCorrosionDrone(game, dt) {
                this.updateBasicAI(game, dt);

                // Spray acid periodically
                if (this.acidSprayTimer <= 0) {
                    this.acidSprayTimer = randomInt(120, 240) / 60; // seconds
                    this.sprayAcid(game);
                }
            }

            sprayAcid(game) {
                // Create acid projectiles
                for (let i = 0; i < 3; i++) {
                    const angle = (Math.PI * 2 * i) / 3;
                    const projectile = new Projectile(
                        this.x,
                        this.y,
                        Math.cos(angle) * 100, // px/s
                        Math.sin(angle) * 100,
                        'acid'
                    );
                    game.projectiles.push(projectile);
                }
            }

            findValidTeleportPosition(game, targetX, targetY, maxRadiusTiles = 6) {
                const attempts = 60;
                const radiusPx = maxRadiusTiles * TILE_SIZE;

                for (let i = 0; i < attempts; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = TILE_SIZE + Math.random() * radiusPx;
                    const tx = clamp(targetX + Math.cos(angle) * dist, TILE_SIZE, CANVAS_WIDTH - TILE_SIZE);
                    const ty = clamp(targetY + Math.sin(angle) * dist, TILE_SIZE, CANVAS_HEIGHT - TILE_SIZE);

                    if (!this.checkCollision(tx, ty, game.level.grid)) {
                        return { x: tx, y: ty };
                    }
                }
                // Fallback: stay in place
                return null;
            }

            changeDirection() {
                const directions = [
                    { x: 1, y: 0 }, { x: -1, y: 0 },
                    { x: 0, y: 1 }, { x: 0, y: -1 }
                ];
                this.direction = directions[randomInt(0, directions.length - 1)];
            }

            // Only solid/destructible/powerup block enemies. Hazards are non-blocking.
            checkCollision(x, y, grid) {
                const bounds = {
                    left: x - this.width / 2,
                    right: x + this.width / 2,
                    top: y - this.height / 2,
                    bottom: y + this.height / 2
                };

                const minTileX = Math.floor(bounds.left / TILE_SIZE);
                const maxTileX = Math.floor(bounds.right / TILE_SIZE);
                const minTileY = Math.floor(bounds.top / TILE_SIZE);
                const maxTileY = Math.floor(bounds.bottom / TILE_SIZE);

                for (let ty = minTileY; ty <= maxTileY; ty++) {
                    for (let tx = minTileX; tx <= maxTileX; tx++) {
                        if (ty >= 0 && ty < GRID_HEIGHT && tx >= 0 && tx < GRID_WIDTH) {
                            const tileType = grid[ty][tx];
                            if (tileType === TILE_TYPE.WALL_SOLID ||
                                tileType === TILE_TYPE.WALL_DESTRUCTIBLE ||
                                tileType === TILE_TYPE.POWERUP) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            takeDamage(amount) {
                // Purple enemies are always vulnerable but weaker overall
                // Reduce damage from contact for fairness
                if (this.type === ENEMY_TYPE.NODE_WISP && amount >= 10) {
                    amount = 6; // soften contact damage
                }

                // Shield Bearer is immune during shield rotation
                if (this.type === ENEMY_TYPE.SHIELD_BEARER && this.shieldActive) {
                    return false;
                }

                this.health -= amount;
                if (this.health <= 0) {
                    this.active = false;
                }
                return true;
            }

            render(ctx) {
                ctx.save();

                let color, glowColor;
                switch (this.type) {
                    case ENEMY_TYPE.PATROL_DRONE:
                        color = '#ff0044';
                        glowColor = '#ff0044';
                        break;
                    case ENEMY_TYPE.SENTINEL_CONSTRUCT:
                        color = '#ff8800';
                        glowColor = '#ff8800';
                        break;
                    case ENEMY_TYPE.CORROSION_DRONE:
                        color = '#00ff44';
                        glowColor = '#00ff44';
                        break;
                    case ENEMY_TYPE.NODE_WISP: // Purple - reworked indicator
                        color = '#8800ff';
                        glowColor = '#8800ff';
                        break;
                    case ENEMY_TYPE.CRYSTAL_LEECH:
                        color = '#00ffff';
                        glowColor = '#00ffff';
                        break;
                    case ENEMY_TYPE.SHIELD_BEARER:
                        color = '#ffff00';
                        glowColor = '#ffff00';
                        break;
                    case ENEMY_TYPE.GRAVITY_SKITTER:
                        color = '#ff00ff';
                        glowColor = '#ff00ff';
                        break;
                    case ENEMY_TYPE.ARCHITECT_SHARD:
                        color = '#ffffff';
                        glowColor = '#ffffff';
                        break;
                }

                // Improved models for all enemies
                switch (this.type) {
                    case ENEMY_TYPE.PATROL_DRONE:
                        renderPatrolDroneModel(ctx, this, color, glowColor);
                        break;
                    case ENEMY_TYPE.SENTINEL_CONSTRUCT:
                        renderSentinelConstructModel(ctx, this, color, glowColor);
                        break;
                    case ENEMY_TYPE.CORROSION_DRONE:
                        renderCorrosionDroneModel(ctx, this, color, glowColor);
                        break;
                    case ENEMY_TYPE.NODE_WISP:
                        renderNodeWispModel(ctx, this, color, glowColor);
                        break;
                    case ENEMY_TYPE.CRYSTAL_LEECH:
                        renderCrystalLeechModel(ctx, this, color, glowColor);
                        break;
                    case ENEMY_TYPE.SHIELD_BEARER:
                        renderShieldBearerModel(ctx, this, color, glowColor);
                        break;
                    case ENEMY_TYPE.GRAVITY_SKITTER:
                        renderGravitySkitterModel(ctx, this, color, glowColor);
                        break;
                    case ENEMY_TYPE.ARCHITECT_SHARD:
                        renderArchitectShardModel(ctx, this, color, glowColor);
                        break;
                    default:
                        // fallback simple body
                        ctx.fillStyle = color;
                        ctx.fillRect(this.x - 10, this.y - 10, 20, 20);
                }

                // Health indicator for tougher enemies
                if (this.maxHealth > 1) {
                    const healthPercent = this.health / this.maxHealth;
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(this.x - 10, this.y - 15, 20 * healthPercent, 3);
                }

                // Flashing red outline for the enemy that hurt the player
                if (window._game && window._game.isEnemyHighlighted(this)) {
                    ctx.globalAlpha = 0.5 + 0.5 * Math.sin(Date.now() * 0.02);
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 14, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }

                ctx.restore();
            }
        }

        class Boss extends Entity {
            constructor(x, y, type, health) {
                super(x, y, TILE_SIZE * 2, TILE_SIZE * 2);
                this.type = type;
                this.health = health;
                this.maxHealth = health;
                this.phase = 1;
                this.attackPattern = 0;
                this.attackTimer = 0; // seconds
                this.armRotation = 0; // radians
                this.shieldDrone = null;
                this.coreExposure = false;
                this.resonanceField = null;

                // Visual telegraph timers for attacks
                this.telegraphTimer = 0;  // seconds showing a warning before attack
                this.attackState = 'idle'; // 'idle' | 'telegraph' | 'attack'
                this.currentAttack = null; // name of current attack
                this.nextAttackIn = randomInt(1, 2); // seconds to next telegraph
            }

            update(game, dt) {
                this.attackTimer -= dt;
                this.telegraphTimer -= dt;

                switch (this.type) {
                    case BOSS_TYPE.SENTINEL_NODE_ALPHA:
                        this.updateSentinelNodeAlpha(game, dt);
                        break;
                    case BOSS_TYPE.WARDEN_K79:
                        this.updateWardenK79(game, dt);
                        break;
                    case BOSS_TYPE.ARCHITECT_PRIME:
                        this.updateArchitectPrime(game, dt);
                        break;
                }

                this.updateAnimation(dt);
            }

            updateSentinelNodeAlpha(game, dt) {
                // Three rotating arms with different attack patterns
                this.armRotation += 0.6 * dt; // radians/sec

                if (this.attackState === 'idle') {
                    this.nextAttackIn -= dt;
                    if (this.nextAttackIn <= 0) {
                        // Start telegraph for random attack
                        this.currentAttack = ['laserSweep', 'crushingStrike', 'energyBurst'][randomInt(0, 2)];
                        this.telegraphTimer = 1.25;
                        this.attackState = 'telegraph';
                        if (this.currentAttack === 'laserSweep') {
                            // Prepare sweep effect
                            const sweep = new LaserSweepEffect(this.x, this.y, this.armRotation);
                            game.effects.push(sweep);
                        }
                    }
                } else if (this.attackState === 'telegraph') {
                    if (this.telegraphTimer <= 0) {
                        // Fire the attack
                        if (this.currentAttack === 'laserSweep') {
                            this.laserSweep(game);
                        } else if (this.currentAttack === 'crushingStrike') {
                            this.crushingStrike(game);
                        } else {
                            this.energyBurst(game);
                        }
                        this.attackState = 'idle';
                        this.nextAttackIn = 2.5; // cooldown
                    }
                }
            }

            updateWardenK79(game, dt) {
                // Modular armor with shield drone
                if (!this.shieldDrone && Math.random() < 0.01 * dt * 60) {
                    this.shieldDrone = new ShieldDrone(this.x, this.y, 0);
                    game.entities.push(this.shieldDrone);
                }

                if (this.attackState === 'idle') {
                    this.nextAttackIn -= dt;
                    if (this.nextAttackIn <= 0) {
                        const attacks = ['barrage', 'slam'];
                        this.currentAttack = attacks[randomInt(0, attacks.length - 1)];
                        this.telegraphTimer = this.currentAttack === 'barrage' ? 1.0 : 1.25;
                        this.attackState = 'telegraph';

                        if (this.currentAttack === 'slam') {
                            // Telegraph effect on arena
                            const shock = new GroundSlamTelegraph(this.x, this.y, 120);
                            game.effects.push(shock);
                        } else {
                            // Prepare barrage spark lines (cosmetic)
                        }
                    }
                } else if (this.attackState === 'telegraph') {
                    if (this.telegraphTimer <= 0) {
                        this.performAttack(game, this.currentAttack);
                        this.attackState = 'idle';
                        this.nextAttackIn = 2.8;
                    }
                }
            }

            updateArchitectPrime(game, dt) {
                // Reality-bending boss with multiple phases
                if (this.phase === 1 && this.health < this.maxHealth * 0.7) {
                    this.phase = 2;
                    this.coreExposure = true;
                } else if (this.phase === 2 && this.health < this.maxHealth * 0.3) {
                    this.phase = 3;
                    this.resonanceField = new ResonanceField(this.x, this.y);
                    game.entities.push(this.resonanceField);
                }

                if (this.attackState === 'idle') {
                    this.nextAttackIn -= dt;
                    if (this.nextAttackIn <= 0) {
                        this.currentAttack = 'realityDistortion';
                        this.telegraphTimer = 1.5;
                        this.attackState = 'telegraph';

                        if (this.phase >= 2) {
                            const swarm = new MicroDroneSwarmEffect(this.x, this.y);
                            game.effects.push(swarm);
                        } else {
                            const pulse = new TimeDistortionPulse(this.x, this.y);
                            game.effects.push(pulse);
                        }
                    }
                } else if (this.attackState === 'telegraph') {
                    if (this.telegraphTimer <= 0) {
                        this.performRealityAttack(game);
                        this.attackState = 'idle';
                        this.nextAttackIn = 2.0;
                    }
                }
            }

            laserSweep(game) {
                // Create sweeping laser beam
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 * i) / 5 + this.armRotation;
                    const projectile = new Projectile(
                        this.x,
                        this.y,
                        Math.cos(angle) * 120,
                        Math.sin(angle) * 120,
                        'laser'
                    );
                    game.projectiles.push(projectile);
                }
            }

            crushingStrike(game) {
                // Wide area slam attack
                const shockwave = new Shockwave(this.x, this.y, 100);
                game.effects.push(shockwave);
            }

            energyBurst(game) {
                // Radial energy orbs
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI * 2 * i) / 8;
                    const projectile = new Projectile(
                        this.x,
                        this.y,
                        Math.cos(angle) * 120,
                        Math.sin(angle) * 120,
                        'energy_orb'
                    );
                    game.projectiles.push(projectile);
                }
            }

            performAttack(game, attackType) {
                switch (attackType) {
                    case 'barrage':
                        for (let i = 0; i < 6; i++) {
                            setTimeout(() => {
                                const angle = (Math.PI * 2 * i) / 6;
                                const projectile = new Projectile(
                                    this.x,
                                    this.y,
                                    Math.cos(angle) * 130,
                                    Math.sin(angle) * 130,
                                    'plasma'
                                );
                                game.projectiles.push(projectile);
                            }, i * 200);
                        }
                        break;
                    case 'slam':
                        const slam = new Shockwave(this.x, this.y, 120);
                        game.effects.push(slam);
                        break;
                }
            }

            performRealityAttack(game) {
                // Create reality distortion effects
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const x = randomInt(100, CANVAS_WIDTH - 100);
                        const y = randomInt(100, CANVAS_HEIGHT - 100);
                        const distortion = new RealityDistortion(x, y);
                        game.effects.push(distortion);
                    }, i * 300);
                }
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.health = 0;
                    this.active = false;
                }
            }

            render(ctx) {
                ctx.save();

                // Improved boss models
                switch (this.type) {
                    case BOSS_TYPE.SENTINEL_NODE_ALPHA:
                        renderSentinelNodeAlphaModel(ctx, this);
                        break;
                    case BOSS_TYPE.WARDEN_K79:
                        renderWardenK79Model(ctx, this);
                        break;
                    case BOSS_TYPE.ARCHITECT_PRIME:
                        renderArchitectPrimeModel(ctx, this);
                        break;
                    default:
                        // fallback basic body
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                }

                // Health bar above boss is handled in UI rendering
                ctx.restore();
            }
        }

        class Projectile extends Entity {
            constructor(x, y, vx, vy, type) {
                super(x, y, 8, 8);
                this.vx = vx;
                this.vy = vy;
                this.type = type;
                this.lifetime = 5; // seconds
                // Trail history for improved visuals
                this.trail = [];
                this.maxTrail = 6;
            }

            update(game, dt) {
                // trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrail) this.trail.shift();

                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.lifetime -= dt;

                // Remove if out of bounds or lifetime expired
                if (this.x < 0 || this.x > CANVAS_WIDTH ||
                    this.y < 0 || this.y > CANVAS_HEIGHT ||
                    this.lifetime <= 0) {
                    this.active = false;
                }

                // Check collision with player
                if (game.player && this.intersects(game.player)) {
                    game.player.takeDamage(15);
                    game.markEnemyAsAttacker(null); // projectiles don't have an enemy ref
                    this.active = false;
                }

                // Check collision with bombs to trigger
                for (let bomb of game.bombs) {
                    if (this.intersects(bomb)) {
                        bomb.timeout = 0;
                        bomb.timer = 0;
                        this.active = false;
                        break;
                    }
                }
            }

            render(ctx) {
                ctx.save();

                let color, glowColor;
                switch (this.type) {
                    case 'acid':
                        color = '#00ff44';
                        glowColor = '#22ff88';
                        break;
                    case 'laser':
                        color = '#ff0000';
                        glowColor = '#ff6666';
                        break;
                    case 'energy_orb':
                        color = '#ffff00';
                        glowColor = '#ffee66';
                        break;
                    case 'plasma':
                        color = '#8800ff';
                        glowColor = '#bb88ff';
                        break;
                    default:
                        color = '#ffffff';
                        glowColor = '#cccccc';
                }

                // Draw trail
                for (let i = 0; i < this.trail.length - 1; i++) {
                    const p0 = this.trail[i];
                    const p1 = this.trail[i + 1];
                    const alpha = (i + 1) / this.trail.length * 0.5;
                    ctx.strokeStyle = color;
                    ctx.globalAlpha = alpha;
                    ctx.lineWidth = lerp(1, 3, (i + 1) / this.trail.length);
                    ctx.beginPath();
                    ctx.moveTo(p0.x, p0.y);
                    ctx.lineTo(p1.x, p1.y);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;

                // Core glow
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = 12;

                // Core body with gradient
                const grad = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, 6);
                grad.addColorStop(0, '#ffffff');
                grad.addColorStop(0.4, color);
                grad.addColorStop(1, 'rgba(255,255,255,0)');

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                ctx.fill();

                // Hard core
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Shockwave extends Entity {
            constructor(x, y, radius) {
                super(x, y, radius * 2, radius * 2);
                this.radius = radius;
                this.maxRadius = radius;
                this.lifetime = 1; // seconds
            }

            update(game, dt) {
                this.lifetime -= dt;
                if (this.lifetime <= 0) {
                    this.active = false;
                }

                // Check damage to player
                const dist = distance(this.x, this.y, game.player.x, game.player.y);
                if (dist <= this.radius && game.player) {
                    game.player.takeDamage(20);
                }
            }

            render(ctx) {
                ctx.save();

                const alpha = this.lifetime / 1;
                ctx.globalAlpha = alpha;

                ctx.strokeStyle = '#ff4400';
                ctx.lineWidth = 5;
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.maxRadius - this.radius, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }
        }

        class RealityDistortion extends Entity {
            constructor(x, y) {
                super(x, y, 100, 100);
                this.totalLife = 1.5; // seconds
                this.lifetime = this.totalLife;
                this.swirlSpeed = 2.0; // radians/sec (controls wave phase speed)
                this.seed = Math.random() * Math.PI * 2;
                this.wavePhase = 0;
                this.baseAlpha = 0.65;
                this.maxRings = 6;
                this.spokes = 12;
                this.ringSpacing = 18;
                this.initialRadius = 24;
            }

            update(game, dt) {
                this.lifetime -= dt;
                this.wavePhase += this.swirlSpeed * dt;
                if (this.lifetime <= 0) {
                    this.active = false;
                }

                // Affect player movement and bomb timing
                if (game.player && this.intersects(game.player)) {
                    const prevSpeed = game.player.speed;
                    game.player.speed *= 0.5; // slow down while inside
                    game.player.distortionSlowTimer = 0.15;

                    // If previously outside, nudge to avoid becoming completely stuck
                    if (!this._wasInside) {
                        game.player.vx = -game.player.vx;
                        game.player.vy = -game.player.vy;
                    }
                    this._wasInside = true;
                } else {
                    this._wasInside = false;
                }

                for (let bomb of game.bombs) {
                    if (distance(this.x, this.y, bomb.x, bomb.y) < 50) {
                        bomb.timer = Math.max(bomb.timer - dt, 0);
                    }
                }
            }

            render(ctx) {
                ctx.save();

                // Visibility: ensure alpha is always visible and smoothly fades only near the end
                const lifeRatio = clamp(this.lifetime / this.totalLife, 0, 1); // 1..0 over lifetime
                const fadeOut = clamp((lifeRatio - 0.2) / 0.8, 0, 1); // keep bright until last 20%
                const baseAlpha = this.baseAlpha * fadeOut;

                // Subtle flicker to avoid banding/complete disappearance
                const flicker = 0.9 + Math.sin(this.wavePhase * 2 + this.seed) * 0.1; // 0.8..1.0
                const alpha = clamp(baseAlpha * flicker, 0.15, this.baseAlpha);

                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = alpha;

                // Radial rings with wavy offset
                for (let i = 0; i < this.maxRings; i++) {
                    const baseR = this.initialRadius + i * this.ringSpacing;
                    const amp = 6 + i * 2;
                    const segments = 56;
                    ctx.beginPath();
                    for (let j = 0; j <= segments; j++) {
                        const theta = (j / segments) * Math.PI * 2;
                        // Combine two sine waves to create a more interesting ripple
                        const r = baseR + Math.sin(theta * 4 + this.wavePhase + this.seed) * amp
                                    + Math.sin(theta * 8 - this.wavePhase * 1.5 + i) * amp * 0.35;
                        const px = this.x + Math.cos(theta) * r;
                        const py = this.y + Math.sin(theta) * r;
                        if (j === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                    }
                    ctx.closePath();

                    // Gradient stroke for glow along the ring
                    const grad = ctx.createRadialGradient(this.x, this.y, baseR - 10, this.x, this.y, baseR + 18);
                    grad.addColorStop(0.0, 'rgba(136,0,255,0.0)');
                    grad.addColorStop(0.45, 'rgba(170,120,255,0.7)');
                    grad.addColorStop(1.0, 'rgba(136,0,255,0.0)');
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = 3 - i * 0.25;
                    ctx.stroke();
                }

                // Spokes: rotating "distortion beams"
                ctx.lineCap = 'round';
                for (let k = 0; k < this.spokes; k++) {
                    const a0 = this.wavePhase * 1.2 + (k / this.spokes) * Math.PI * 2 + Math.sin(k + this.seed) * 0.2;
                    const a1 = a0 + Math.PI / 5;
                    const r0 = 12 + Math.sin(this.wavePhase * 2 + k) * 6;
                    const r1 = 90 + k * 8 + Math.cos(this.wavePhase * 1.4 + k * 0.5) * 10;

                    const x0 = this.x + Math.cos(a0) * r0;
                    const y0 = this.y + Math.sin(a0) * r0;
                    const x1 = this.x + Math.cos(a1) * r1;
                    const y1 = this.y + Math.sin(a1) * r1;

                    const lineGrad = ctx.createLinearGradient(x0, y0, x1, y1);
                    lineGrad.addColorStop(0, 'rgba(220,200,255,0.25)');
                    lineGrad.addColorStop(0.35, 'rgba(170,120,255,0.7)');
                    lineGrad.addColorStop(1, 'rgba(136,0,255,0.05)');

                    ctx.strokeStyle = lineGrad;
                    ctx.lineWidth = 2.0 - (k % 3) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(x0, y0);
                    ctx.lineTo(x1, y1);
                    ctx.stroke();
                }

                // Central well: bright, pulsing core
                const coreR = 10 + Math.sin(this.wavePhase * 2.5 + this.seed) * 4;
                ctx.fillStyle = 'rgba(200,160,255,0.8)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, coreR, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class ResonanceField extends Entity {
            constructor(x, y) {
                super(x, y, 200, 200);
                this.lifetime = 10; // seconds
                this.pulsePhase = 0;
            }

            update(game, dt) {
                this.lifetime -= dt;
                this.pulsePhase += 0.05 * dt;

                if (this.lifetime <= 0) {
                    this.active = false;
                }

                // Time distortion effect: toggle gravity inversion periodically while inside
                if (game.player && this.intersects(game.player)) {
                    if (Math.random() < 0.02 * dt * 60) {
                        game.player.gravityInverted = !game.player.gravityInverted;
                        game.player.gravityTimer = 3; // 3 seconds
                    }
                }
            }

            render(ctx) {
                ctx.save();

                const alpha = this.lifetime / 10;
                const pulse = Math.sin(this.pulsePhase) * 0.1 + 0.2;

                ctx.globalAlpha = alpha * pulse;

                // Pulsing resonance field
                ctx.fillStyle = '#8800ff';
                ctx.shadowColor = '#8800ff';
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 80 + Math.sin(this.pulsePhase) * 20, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class Bomb extends Entity {
            constructor(x, y, radius, piercing = false) {
                super(x, y, 16, 16);
                this.timeout = 1.0;
                this.radius = radius;
                this.timer = this.timeout;
                this.exploded = false;
                this.piercing = piercing;
            }

            update(game, dt) {
                if (!this.exploded) {
                    // De-activate timer if player has remote detonation (manual trigger only)
                    if (game.player && game.player.remoteDetonation) {
                        // Keep the bomb armed but do not count down automatically
                        // The player must use X to detonate
                        this.timer = this.timeout;
                    } else {
                        this.timer -= dt;
                    }
                    if (this.timer <= 0) {
                        this.explode(game);
                    }
                }
            }

            explode(game) {
                this.exploded = true;
                this.active = false;

                // Create explosion effect
                game.explosions.push(new Explosion(this.x, this.y, this.radius));

                // Play sound
                game.audioSystem.playBombExplosion();

                // Damage enemies and destroy tiles
                this.checkExplosionDamage(game);

                // Remove from player's bomb list (if present)
                const idx = game.player.bombs.indexOf(this);
                if (idx !== -1) {
                    game.player.bombs.splice(idx, 1);
                }
            }

            checkExplosionDamage(game) {
                const centerTileX = Math.floor(this.x / TILE_SIZE);
                const centerTileY = Math.floor(this.y / TILE_SIZE);
                const spawnFlags = []; // remember tiles that should spawn power-ups along each arm before clearing them

                // Damage anything sitting on the bomb's own tile first (bypass LOS blocks).
                this.applyCenterTileDamage(game);

                // Check explosion in all directions (now with line-of-sight damage to player only in the same row/column)
                const directions = [
                    { x: 1, y: 0 }, { x: -1, y: 0 },
                    { x: 0, y: 1 }, { x: 0, y: -1 }
                ];

                for (const dir of directions) {
                    let blocked = false;
                    for (let i = 0; i < this.radius && !blocked; i++) {
                        const checkX = centerTileX + dir.x * i;
                        const checkY = centerTileY + dir.y * i;

                        if (checkX >= 0 && checkX < GRID_WIDTH &&
                            checkY >= 0 && checkY < GRID_HEIGHT) {

                            const tileType = game.level.grid[checkY][checkX];

                            // Remember if this destructible tile originally was a power-up tile so we can spawn it later
                            let shouldSpawn = false;
                            if (tileType === TILE_TYPE.POWERUP) {
                                shouldSpawn = true;
                            } else if (tileType === TILE_TYPE.WALL_DESTRUCTIBLE) {
                                // Destructible walls may contain hidden power-ups; 15% chance to spawn one
                                if (Math.random() < 0.15) shouldSpawn = true;
                            }

                            // Destroy destructible walls and power-up tiles
                            if (tileType === TILE_TYPE.WALL_DESTRUCTIBLE ||
                                tileType === TILE_TYPE.POWERUP) {

                                if (shouldSpawn) {
                                    spawnFlags.push({ x: checkX, y: checkY });
                                }

                                game.level.grid[checkY][checkX] = TILE_TYPE.EMPTY;

                                // Stop propagation unless piercing
                                if (!this.piercing) blocked = true;
                            }

                            // CRITICAL FIX: Piercing explosions are blocked by indestructible rocks
                            if (tileType === TILE_TYPE.WALL_SOLID) {
                                blocked = true;
                            }

                            // Check power-ups floating in the explosion area and remove them
                            for (let j = game.powerUps.length - 1; j >= 0; j--) {
                                const powerUp = game.powerUps[j];
                                const tileX = Math.floor(powerUp.x / TILE_SIZE);
                                const tileY = Math.floor(powerUp.y / TILE_SIZE);

                                if (tileX === checkX && tileY === checkY) {
                                    game.powerUps.splice(j, 1);
                                }
                            }
                        } else {
                            // Out of bounds stops propagation
                            blocked = true;
                        }
                    }
                }

                // Spawn any power-ups that were marked for this bomb's explosion
                for (const flag of spawnFlags) {
                    game.powerUps.push(new PowerUp(
                        flag.x * TILE_SIZE + TILE_SIZE / 2,
                        flag.y * TILE_SIZE + TILE_SIZE / 2
                    ));
                }

                // Damage enemies in explosion range (aligned LOS only)
                const alignedDamageRange = this.radius * TILE_SIZE;
                for (let i = game.enemies.length - 1; i >= 0; i--) {
                    const enemy = game.enemies[i];
                    const enemyTileX = Math.floor(enemy.x / TILE_SIZE);
                    const enemyTileY = Math.floor(enemy.y / TILE_SIZE);

                    let inLine = false;

                    // Check row alignment
                    if (enemyTileY === centerTileY) {
                        const dxTiles = Math.abs(enemyTileX - centerTileX);
                        inLine = dxTiles > 0 && dxTiles <= this.radius;
                        if (inLine) {
                            // Verify LOS along the row
                            const minX = Math.min(centerTileX, enemyTileX);
                            const maxX = Math.max(centerTileX, enemyTileX);
                            inLine = false;
                            let blocked = false;
                            for (let tx = minX + 1; tx < maxX; tx++) {
                                const t = game.level.grid[centerTileY][tx];
                                if (t === TILE_TYPE.WALL_SOLID || t === TILE_TYPE.WALL_DESTRUCTIBLE) {
                                    blocked = true; break;
                                }
                            }
                            if (!blocked) inLine = true;
                        }
                    }

                    // Check column alignment
                    if (!inLine && enemyTileX === centerTileX) {
                        const dyTiles = Math.abs(enemyTileY - centerTileY);
                        inLine = dyTiles > 0 && dyTiles <= this.radius;
                        if (inLine) {
                            // Verify LOS along the column
                            const minY = Math.min(centerTileY, enemyTileY);
                            const maxY = Math.max(centerTileY, enemyTileY);
                            inLine = false;
                            let blocked = false;
                            for (let ty = minY + 1; ty < maxY; ty++) {
                                const t = game.level.grid[ty][centerTileX];
                                if (t === TILE_TYPE.WALL_SOLID || t === TILE_TYPE.WALL_DESTRUCTIBLE) {
                                    blocked = true; break;
                                }
                            }
                            if (!blocked) inLine = true;
                        }
                    }

                    if (inLine) {
                        if (enemy.takeDamage(1)) {
                            game.audioSystem.playEnemyDeath();
                            game.enemies.splice(i, 1);
                        }
                    }
                }

                // Boss damage: aligned only
                if (game.boss) {
                    const bossTileX = Math.floor(game.boss.x / TILE_SIZE);
                    const bossTileY = Math.floor(game.boss.y / TILE_SIZE);

                    let aligned = false;

                    if (bossTileY === centerTileY) {
                        const dxTiles = Math.abs(bossTileX - centerTileX);
                        aligned = dxTiles > 0 && dxTiles <= this.radius;
                        if (aligned) {
                            // Verify LOS along the row
                            const minX = Math.min(centerTileX, bossTileX);
                            const maxX = Math.max(centerTileX, bossTileX);
                            aligned = false;
                            let blocked = false;
                            for (let tx = minX + 1; tx < maxX; tx++) {
                                const t = game.level.grid[centerTileY][tx];
                                if (t === TILE_TYPE.WALL_SOLID || t === TILE_TYPE.WALL_DESTRUCTIBLE) {
                                    blocked = true; break;
                                }
                            }
                            if (!blocked) aligned = true;
                        }
                    }

                    if (!aligned && bossTileX === centerTileX) {
                        const dyTiles = Math.abs(bossTileY - centerTileY);
                        aligned = dyTiles > 0 && dyTiles <= this.radius;
                        if (aligned) {
                            // Verify LOS along the column
                            const minY = Math.min(centerTileY, bossTileY);
                            const maxY = Math.max(centerTileY, bossTileY);
                            aligned = false;
                            let blocked = false;
                            for (let ty = minY + 1; ty < maxY; ty++) {
                                const t = game.level.grid[ty][centerTileX];
                                if (t === TILE_TYPE.WALL_SOLID || t === TILE_TYPE.WALL_DESTRUCTIBLE) {
                                    blocked = true; break;
                                }
                            }
                            if (!blocked) aligned = true;
                        }
                    }

                    if (aligned) {
                        game.boss.takeDamage(2);
                    }
                }

                // Player damage: only when aligned horizontally/vertically with bomb center and within arm length
                if (game.player) {
                    const pCenterX = game.player.x;
                    const pCenterY = game.player.y;
                    const playerTileX = Math.floor(pCenterX / TILE_SIZE);
                    const playerTileY = Math.floor(pCenterY / TILE_SIZE);

                    // Same row or same column and within this bomb's horizontal/vertical arm length
                    const sameRow = (playerTileY === centerTileY);
                    const sameCol = (playerTileX === centerTileX);

                    let inLine = false;
                    if (sameRow) {
                        const dxTiles = Math.abs(playerTileX - centerTileX);
                        inLine = dxTiles > 0 && dxTiles <= this.radius;
                    } else if (sameCol) {
                        const dyTiles = Math.abs(playerTileY - centerTileY);
                        inLine = dyTiles > 0 && dyTiles <= this.radius;
                    }

                    // Also ensure LOS along the arms (no blocking wall between)
                    let blocked = false;
                    if (inLine) {
                        if (sameRow) {
                            const minX = Math.min(centerTileX, playerTileX);
                            const maxX = Math.max(centerTileX, playerTileX);
                            blocked = false;
                            for (let tx = minX + 1; tx < maxX; tx++) {
                                const t = game.level.grid[centerTileY][tx];
                                if (t === TILE_TYPE.WALL_SOLID || t === TILE_TYPE.WALL_DESTRUCTIBLE) {
                                    blocked = true; break;
                                }
                            }
                            if (!blocked) {
                                game.player.takeDamage(25);
                            }
                        } else if (sameCol) {
                            const minY = Math.min(centerTileY, playerTileY);
                            const maxY = Math.max(centerTileY, playerTileY);
                            blocked = false;
                            for (let ty = minY + 1; ty < maxY; ty++) {
                                const t = game.level.grid[ty][centerTileX];
                                if (t === TILE_TYPE.WALL_SOLID || t === TILE_TYPE.WALL_DESTRUCTIBLE) {
                                    blocked = true; break;
                                }
                            }
                            if (!blocked) {
                                game.player.takeDamage(25);
                            }
                        }
                    }
                }
            }

            // NEW: Damage enemies and the player occupying the bomb's own tile.
            applyCenterTileDamage(game) {
                const centerTileX = Math.floor(this.x / TILE_SIZE);
                const centerTileY = Math.floor(this.y / TILE_SIZE);

                // Enemies on the center tile
                for (let i = game.enemies.length - 1; i >= 0; i--) {
                    const enemy = game.enemies[i];
                    const enemyTileX = Math.floor(enemy.x / TILE_SIZE);
                    const enemyTileY = Math.floor(enemy.y / TILE_SIZE);
                    if (enemyTileX === centerTileX && enemyTileY === centerTileY) {
                        if (enemy.takeDamage(1)) {
                            game.audioSystem.playEnemyDeath();
                            game.enemies.splice(i, 1);
                        }
                    }
                }

                // Player on the center tile
                if (game.player) {
                    const pTileX = Math.floor(game.player.x / TILE_SIZE);
                    const pTileY = Math.floor(game.player.y / TILE_SIZE);
                    if (pTileX === centerTileX && pTileY === centerTileY) {
                        game.player.takeDamage(25);
                    }
                }

                // Boss on the center tile (optional: feel free to omit if you want boss damage only via aligned LOS)
                if (game.boss) {
                    const bTileX = Math.floor(game.boss.x / TILE_SIZE);
                    const bTileY = Math.floor(game.boss.y / TILE_SIZE);
                    if (bTileX === centerTileX && bTileY === centerTileY) {
                        game.boss.takeDamage(2);
                    }
                }
            }

            render(ctx) {
                ctx.save();

                // Hovering shadow
                ctx.fillStyle = 'rgba(0,0,0,0.35)';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y + 10, 10, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Bomb body with metallic shading
                const bodyGrad = ctx.createLinearGradient(this.x - 10, this.y - 16, this.x + 10, this.y + 16);
                bodyGrad.addColorStop(0, '#22262a');
                bodyGrad.addColorStop(0.5, '#4a5158');
                bodyGrad.addColorStop(1, '#1c2024');
                ctx.fillStyle = bodyGrad;
                roundedRect(ctx, this.x - 10, this.y - 10, 20, 20, 6);

                // Neon edge lines
                ctx.strokeStyle = '#00f7ff';
                ctx.lineWidth = 1.25;
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.moveTo(this.x - 8, this.y - 6); ctx.lineTo(this.x + 8, this.y - 6);
                ctx.moveTo(this.x - 8, this.y + 6); ctx.lineTo(this.x + 8, this.y + 6);
                ctx.stroke();
                ctx.globalAlpha = 1;

                // Top glow core
                const glowGrad = ctx.createRadialGradient(this.x, this.y, 1, this.x, this.y, 8);
                glowGrad.addColorStop(0, '#aaffff');
                glowGrad.addColorStop(1, 'rgba(0,255,255,0)');
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                ctx.fill();

                // Fuse indicator
                const fusePercent = this.timer / this.timeout;
                ctx.strokeStyle = '#ff4400';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 10, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * fusePercent));
                ctx.stroke();

                // Piercing indicator
                if (this.piercing) {
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 12, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.restore();
            }
        }

        class Explosion extends Entity {
            constructor(x, y, radius) {
                super(x, y, radius * TILE_SIZE * 2, radius * TILE_SIZE * 2);
                this.radius = radius;
                this.timer = 0.5; // seconds
                this.centerX = x;
                this.centerY = y;
                this.particles = [];
                this.flashPhase = 0; // for shockwave rings and debris timing

                // Create particles for enhanced effect
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 * i) / 20;
                    const speed = randomInt(30, 90); // px/sec
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 0.25, // seconds
                        color: `hsl(${randomInt(0, 60)}, 100%, 50%)`
                    });
                }
            }

            update(game, dt) {
                this.timer -= dt;
                this.flashPhase += dt;

                // Update particles
                for (let particle of this.particles) {
                    particle.x += particle.vx * dt;
                    particle.y += particle.vy * dt;
                    particle.life -= dt;
                }

                // Remove dead particles
                this.particles = this.particles.filter(p => p.life > 0);

                if (this.timer <= 0 && this.particles.length === 0) {
                    this.active = false;
                }

                // Chain-detonate bombs only when aligned and not blocked
                this.processAlignedBombChain(game);
            }

            processAlignedBombChain(game) {
                const centerTileX = Math.floor(this.centerX / TILE_SIZE);
                const centerTileY = Math.floor(this.centerY / TILE_SIZE);

                const directions = [
                    { x: 1, y: 0 }, { x: -1, y: 0 },
                    { x: 0, y: 1 }, { x: 0, y: -1 }
                ];

                for (const dir of directions) {
                    let blocked = false;
                    for (let i = 1; i <= this.radius && !blocked; i++) {
                        const checkX = centerTileX + dir.x * i;
                        const checkY = centerTileY + dir.y * i;

                        if (checkX < 0 || checkX >= GRID_WIDTH || checkY < 0 || checkY >= GRID_HEIGHT) {
                            blocked = true; continue;
                        }

                        const tileType = game.level.grid[checkY][checkX];
                        if (tileType === TILE_TYPE.WALL_SOLID || tileType === TILE_TYPE.WALL_DESTRUCTIBLE) {
                            blocked = true;
                        }

                        // Trigger bombs on the same row/column in LOS
                        for (let bomb of game.bombs) {
                            if (!bomb.active || bomb.exploded) continue;
                            const bTileX = Math.floor(bomb.x / TILE_SIZE);
                            const bTileY = Math.floor(bomb.y / TILE_SIZE);
                            if (bTileX === checkX && bTileY === checkY) {
                                // Trigger after a short delay that scales with distance (chain timing)
                                const delay = Math.max(0.04, 0.06 - i * 0.004); // closer -> faster
                                bomb.timer = Math.min(bomb.timer, delay);
                            }
                        }
                    }
                }
            }

            render(ctx) {
                ctx.save();

                const alpha = this.timer / 0.5;
                const t = 1 - alpha; // progress 0..1

                // Base intensity mapping
                let baseGlow = clamp(1 - t * 1.2, 0, 1);
                let ringProgress = clamp((t - 0.2) / 0.8, 0, 1);
                let debrisAlpha = clamp(1 - t * 2.0, 0, 1);

                // Central bright flash and core
                const flashRadius = 18 + t * 8;
                ctx.globalCompositeOperation = 'lighter';

                // Core flash
                const grad = ctx.createRadialGradient(this.centerX, this.centerY, 2, this.centerX, this.centerY, flashRadius);
                grad.addColorStop(0, `rgba(255,255,255,${0.85 * baseGlow})`);
                grad.addColorStop(0.4, `rgba(255,200,80,${0.6 * baseGlow})`);
                grad.addColorStop(1, 'rgba(255,120,0,0)');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(this.centerX, this.centerY, flashRadius, 0, Math.PI * 2);
                ctx.fill();

                // Cross-arms glow
                const armWidth = 26;
                ctx.fillStyle = `rgba(255, ${Math.floor(140 + 100*ringProgress)}, 40, ${0.35 + 0.25 * (1 - ringProgress)})`;
                // Center
                roundedRect(ctx, this.centerX - armWidth/2, this.centerY - armWidth/2, armWidth, armWidth, 6);

                // Arms along axes
                const directions = [
                    { x: 1, y: 0 }, { x: -1, y: 0 },
                    { x: 0, y: 1 }, { x: 0, y: -1 }
                ];
                for (const dir of directions) {
                    for (let i = 0; i < this.radius; i++) {
                        const armX = this.centerX + dir.x * i * TILE_SIZE;
                        const armY = this.centerY + dir.y * i * TILE_SIZE;

                        // Inner bright core slice
                        ctx.fillStyle = `rgba(255, 230, 120, ${0.9 * (1 - i / this.radius) * baseGlow})`;
                        roundedRect(ctx, armX - 14, armY - 14, 28, 28, 6);

                        // Outer heat halo
                        ctx.fillStyle = `rgba(255, 120, 40, ${0.5 * (1 - i / this.radius) * baseGlow})`;
                        roundedRect(ctx, armX - 18, armY - 18, 36, 36, 8);
                    }
                }

                // Expanding shock ring
                const shockRadius = 20 + t * (this.radius * TILE_SIZE * 1.4);
                ctx.strokeStyle = `rgba(255, 100, 30, ${0.8 * (1 - ringProgress)})`;
                ctx.lineWidth = 3 + ringProgress * 3;
                ctx.shadowColor = 'rgba(255,120,60,0.8)';
                ctx.shadowBlur = 12 + ringProgress * 24;
                ctx.beginPath();
                ctx.arc(this.centerX, this.centerY, shockRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Secondary ring for depth
                ctx.globalAlpha = 0.7 * (1 - ringProgress);
                ctx.strokeStyle = `rgba(255, 200, 80, ${0.6 * (1 - ringProgress)})`;
                ctx.lineWidth = 1 + ringProgress * 2;
                ctx.beginPath();
                ctx.arc(this.centerX, this.centerY, shockRadius * 0.65, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1.0;

                // Debris particles
                for (let particle of this.particles) {
                    const particleAlpha = debrisAlpha * (particle.life / 1.0);
                    ctx.globalAlpha = particleAlpha;
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;

                ctx.restore();
            }
        }

        class PowerUp extends Entity {
            constructor(x, y) {
                super(x, y, 16, 16);
                this.type = Object.values(POWERUP_TYPE)[randomInt(0, Object.values(POWERUP_TYPE).length - 1)];
                this.bobTimer = 0;
                this.glowPhase = 0;
            }

            update(game, dt) {
                this.bobTimer += dt * 60;
                this.glowPhase += dt * 6;

                // Check collision with player
                if (game.player && this.intersects(game.player)) {
                    game.player.applyPowerUp(this.type);
                    game.audioSystem.playPowerUpPickup();
                    this.active = false;

                    // Show power-up notification
                    game.showNotification(`Acquired: ${this.getPowerUpName()}`, 'powerup');
                }
            }

            getPowerUpName() {
                switch (this.type) {
                    case POWERUP_TYPE.FIREPOWER:
                        return 'Firepower';
                    case POWERUP_TYPE.MULTI_BOMB:
                        return 'Multi-Bomb';
                    case POWERUP_TYPE.SPEED:
                        return 'Speed Boost';
                    case POWERUP_TYPE.REMOTE_DETONATION:
                        return 'Remote Detonation';
                    case POWERUP_TYPE.PIERCING_CHARGE:
                        return 'Piercing Charge';
                    case POWERUP_TYPE.SHIELD_DRONE:
                        return 'Shield Drone';
                    case POWERUP_TYPE.KEYCARD_FRAGMENT:
                        return 'Keycard Fragment';
                    default:
                        return 'Unknown Power-Up';
                }
            }

            render(ctx) {
                ctx.save();

                // Bobbing animation
                const bobOffset = Math.sin(this.bobTimer * 0.1) * 3;
                const glowIntensity = Math.sin(this.glowPhase) * 0.35 + 0.7;

                let color, ringColor, symbol, gemColor;
                switch (this.type) {
                    case POWERUP_TYPE.FIREPOWER:
                        color = '#ff6600';
                        ringColor = '#ffaa44';
                        symbol = 'F';
                        gemColor = '#ffcc99';
                        break;
                    case POWERUP_TYPE.MULTI_BOMB:
                        color = '#0066ff';
                        ringColor = '#44aaff';
                        symbol = 'B';
                        gemColor = '#aaddff';
                        break;
                    case POWERUP_TYPE.SPEED:
                        color = '#00ff00';
                        ringColor = '#66ff99';
                        symbol = 'S';
                        gemColor = '#ccffcc';
                        break;
                    case POWERUP_TYPE.REMOTE_DETONATION:
                        color = '#ff00ff';
                        ringColor = '#ff88ff';
                        symbol = 'R';
                        gemColor = '#ffbbff';
                        break;
                    case POWERUP_TYPE.PIERCING_CHARGE:
                        color = '#ffff00';
                        ringColor = '#ffee77';
                        symbol = 'P';
                        gemColor = '#fff8cc';
                        break;
                    case POWERUP_TYPE.SHIELD_DRONE:
                        color = '#00ffff';
                        ringColor = '#88ffff';
                        symbol = 'D';
                        gemColor = '#ccffff';
                        break;
                    case POWERUP_TYPE.KEYCARD_FRAGMENT:
                        color = '#ffffff';
                        ringColor = '#dddddd';
                        symbol = 'K';
                        gemColor = '#f5f5f5';
                        break;
                    default:
                        color = '#8800ff';
                        ringColor = '#bb99ff';
                        symbol = '?';
                        gemColor = '#d9c6ff';
                        break;
                }

                // Orbiting rings
                ctx.globalAlpha = glowIntensity;
                ctx.strokeStyle = ringColor;
                ctx.lineWidth = 2;
                for (let i = 0; i < 2; i++) {
                    const r = 10 + i * 4 + Math.sin(this.glowPhase + i) * 1.5;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y + bobOffset, r, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;

                // Gem body with gradient
                const grad = ctx.createRadialGradient(
                    this.x, this.y + bobOffset, 2,
                    this.x, this.y + bobOffset, 12
                );
                grad.addColorStop(0, gemColor);
                grad.addColorStop(1, color);
                ctx.fillStyle = grad;
                ctx.shadowColor = color;
                ctx.shadowBlur = 14 * glowIntensity;
                roundedRect(ctx, this.x - 10, this.y - 10 + bobOffset, 20, 20, 6);

                // Inner sparkle
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.beginPath();
                ctx.arc(this.x - 4, this.y - 6 + bobOffset, 3, 0, Math.PI * 2);
                ctx.fill();

                // Symbol (kept for readability and identity)
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(symbol, this.x, this.y + 4 + bobOffset);

                ctx.restore();
            }
        }

        // Boss Attack Effects (cosmetic enhancements)
        class LaserSweepEffect extends Entity {
            constructor(x, y, startAngle) {
                super(x, y, 800, 600);
                this.angle = startAngle;
                this.speed = 1.8; // radians/sec
                this.lifetime = 2.2;
                this.width = 6;
            }

            update(game, dt) {
                this.lifetime -= dt;
                this.angle += this.speed * dt;
                if (this.lifetime <= 0) this.active = false;
            }

            render(ctx) {
                ctx.save();
                const alpha = clamp(this.lifetime / 2.2, 0, 1);
                const len = 500;

                ctx.strokeStyle = `rgba(255, 80, 80, ${alpha})`;
                ctx.lineWidth = this.width;
                ctx.shadowColor = '#ff3333';
                ctx.shadowBlur = 18;

                // Draw sweeping beam
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + Math.cos(this.angle) * len, this.y + Math.sin(this.angle) * len);
                ctx.stroke();

                // Soft halo
                ctx.globalAlpha = alpha * 0.4;
                ctx.lineWidth = this.width + 8;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + Math.cos(this.angle) * len, this.y + Math.sin(this.angle) * len);
                ctx.stroke();

                ctx.restore();
            }
        }

        class GroundSlamTelegraph extends Entity {
            constructor(x, y, radius) {
                super(x, y, radius * 2, radius * 2);
                this.radius = 6;
                this.maxRadius = radius;
                this.lifetime = 0.9;
            }

            update(game, dt) {
                this.lifetime -= dt;
                this.radius += 260 * dt;
                if (this.lifetime <= 0) this.active = false;
            }

            render(ctx) {
                ctx.save();
                const alpha = clamp(this.lifetime / 0.9, 0, 1);
                ctx.strokeStyle = `rgba(255, 120, 0, ${alpha})`;
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 8]);
                ctx.shadowColor = '#ff5500';
                ctx.shadowBlur = 14;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
            }
        }

        class MicroDroneSwarmEffect extends Entity {
            constructor(x, y) {
                super(x, y, 400, 400);
                this.lifetime = 4.0;
                this.microdrones = [];
                for (let i = 0; i < 18; i++) {
                    const angle = (Math.PI * 2 * i) / 18;
                    this.microdrones.push({
                        angle,
                        r: 80 + randomInt(-10, 10),
                        spin: randomInt(-40, 40) / 100 // rad/sec
                    });
                }
            }

            update(game, dt) {
                this.lifetime -= dt;
                for (let d of this.microdrones) {
                    d.angle += d.spin * dt;
                }
                if (this.lifetime <= 0) this.active = false;
            }

            render(ctx) {
                ctx.save();
                const alpha = clamp(this.lifetime / 4.0, 0, 1);
                ctx.fillStyle = `rgba(200, 220, 255, ${alpha})`;
                ctx.shadowColor = '#aaccff';
                ctx.shadowBlur = 12;

                for (let d of this.microdrones) {
                    const px = this.x + Math.cos(d.angle) * d.r;
                    const py = this.y + Math.sin(d.angle) * d.r;
                    ctx.beginPath();
                    ctx.arc(px, py, 3, 0, Math.PI * 2);
                    ctx.fill();

                    // Connect neighbors with faint lines for "barrier" feel
                    if (Math.random() < 0.2) {
                        ctx.globalAlpha = alpha * 0.3;
                        ctx.strokeStyle = '#cce0ff';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(this.x + Math.cos(d.angle) * d.r, this.y + Math.sin(d.angle) * d.r);
                        ctx.lineTo(this.x + Math.cos(d.angle + Math.PI / 9) * d.r, this.y + Math.sin(d.angle + Math.PI / 9) * d.r);
                        ctx.stroke();
                        ctx.globalAlpha = alpha;
                    }
                }
                ctx.restore();
            }
        }

        class TimeDistortionPulse extends Entity {
            constructor(x, y) {
                super(x, y, 400, 400);
                this.lifetime = 3.0;
                this.r = 20;
            }

            update(game, dt) {
                this.lifetime -= dt;
                this.r += 120 * dt;
                if (this.lifetime <= 0) this.active = false;
            }

            render(ctx) {
                ctx.save();
                const alpha = clamp(this.lifetime / 3.0, 0, 1);
                ctx.strokeStyle = `rgba(170, 120, 255, ${alpha})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#aa88ff';
                ctx.shadowBlur = 16;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.stroke();

                // second inner pulse
                ctx.globalAlpha = alpha * 0.6;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r * 0.65, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        }

        // The Whisper System
        class WhisperSystem {
            constructor() {
                this.messages = [
                    "Nova... can you hear me? The paths are closing.",
                    "Find the keycard fragments. They will show you the way.",
                    "The Collapse was not an accident. Someone wanted us here.",
                    "Gravity is a suggestion, not a law.",
                    "The Grid remembers fragments of what was lost.",
                    "The exit is not a place. It's a frequency.",
                    "The Architect Prime seeks to harmonize all signals.",
                    "Fragments echo. Align them to hear the path.",
                    "The lanes breathe. Time your steps to their pulse.",
                ];
                this.currentMessage = 0;
                this.active = false;
            }

            displayMessage(message, game) {
                // Remove existing whisper overlay
                const existing = document.querySelector('.whisper-overlay');
                if (existing) {
                    existing.remove();
                }

                const overlay = document.createElement('div');
                overlay.className = 'whisper-overlay';
                overlay.innerHTML = `
                    <h3>THE WHISPER</h3>
                    <p>"${message}"</p>
                    <p><em>Press Enter to continue...</em></p>
                `;

                document.body.appendChild(overlay);

                // Remove on Enter press only
                const removeOverlay = (e) => {
                    if (e.code === 'Enter') {
                        overlay.remove();
                        game.gameState = GAME_STATE.PLAYING;
                        document.removeEventListener('keydown', removeOverlay);
                    }
                };

                document.addEventListener('keydown', removeOverlay);
            }
        }

        // Game Engine
        class Game {
            constructor() {
                this.fpsSmoothed = 60;

                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);

                this.inputSystem = new InputSystem();
                this.audioSystem = new AudioSystem();
                this.whisperSystem = new WhisperSystem();
                this.currentMessageIndex = 0;
                this.levelMessageIndex = 0;

                // Keep a global handle for render access (for highlight check)
                window._game = this;

                this.gameState = GAME_STATE.PLAYING;
                this.currentLevel = 1;
                this.maxLevels = 5;
                this.entities = [];
                this.projectiles = [];
                this.effects = [];
                this.notifications = [];
                this.bossDefeatedThisLevel = false;

                // Attacker highlighting
                this.lastAttackerIndex = null;
                this.highlightTimer = 0;
                this.highlightDuration = 1.25; // seconds

                // Background animation state
                this.bgTime = 0;

                this.initLevel();
                this.setupEventListeners();

                // Start loop with real delta time
                this.lastTime = performance.now();
                this.gameLoop(this.lastTime);
            }

            markEnemyAsAttacker(enemy) {
                if (enemy instanceof Enemy) {
                    const idx = this.enemies.indexOf(enemy);
                    if (idx !== -1) {
                        this.lastAttackerIndex = idx;
                        this.highlightTimer = this.highlightDuration;
                    }
                } else {
                    this.lastAttackerIndex = null;
                    this.highlightTimer = 0;
                }
            }

            isEnemyHighlighted(enemy) {
                const idx = this.enemies.indexOf(enemy);
                return idx === this.lastAttackerIndex && this.highlightTimer > 0;
            }

            initLevel() {
                this.levelMessageIndex = this.currentMessageIndex;
                const keepPlayer = this.player && this.player.active; // carry over power-ups and persistent upgrades

                this.level = LevelGenerator.generateLevel(this.currentLevel);
                if (!keepPlayer) {
                    this.player = new Player(this.level.startPosition.x, this.level.startPosition.y);
                } else {
                    // Re-center player at the new start, but keep all persistent stats
                    this.player.x = this.level.startPosition.x;
                    this.player.y = this.level.startPosition.y;
                    this.player.health = this.player.maxHealth; // refill health each level
                    this.player.bombs = []; // clear placed bombs list per level
                }

                this.enemies = [];
                this.bombs = [];
                this.explosions = [];
                this.powerUps = [];
                this.boss = null;
                this.bossDefeatedThisLevel = false;

                // Clear any existing overlays when initializing a level
                this.removeAllOverlays();

                // Initialize boss if present
                if (this.level.bossData) {
                    this.boss = new Boss(
                        this.level.bossData.position.x,
                        this.level.bossData.position.y,
                        this.level.bossData.type,
                        this.level.bossData.health
                    );
                    this.gameState = GAME_STATE.BOSS_FIGHT;
                    this.audioSystem.playBossTheme();
                } else {
                    this.gameState = GAME_STATE.PLAYING;
                }

                this.spawnEnemies();
                this.updateUI();

                // Show whisper at level start
                setTimeout(() => {
                    const startMsgIdx = Math.min(this.currentLevel - 1, this.whisperSystem.messages.length - 1);
                    if (this.currentMessageIndex < this.whisperSystem.messages.length) {
                        const msg = this.whisperSystem.messages[this.currentMessageIndex++];
                        this.whisperSystem.active = true;
                        this.gameState = GAME_STATE.WHISPER;
                        this.whisperSystem.displayMessage(msg, this);
                    }
                }, 600);
            }

            spawnEnemies() {
                const enemyCount = Math.min(12, 3 + this.currentLevel * 2);
                const enemyTypes = this.getEnemyTypesForLevel();

                for (let i = 0; i < enemyCount; i++) {
                    let x, y;
                    let attempts = 0;

                    do {
                        x = randomInt(2, GRID_WIDTH - 3) * TILE_SIZE + TILE_SIZE / 2;
                        y = randomInt(2, GRID_HEIGHT - 3) * TILE_SIZE + TILE_SIZE / 2;
                        attempts++;
                    } while ((distance(x, y, this.player.x, this.player.y) < 150 ||
                             this.checkTileCollision(x, y)) && attempts < 100);

                    const enemyType = enemyTypes[randomInt(0, enemyTypes.length - 1)];
                    this.enemies.push(new Enemy(x, y, enemyType));
                }
            }

            getEnemyTypesForLevel() {
                switch (this.currentLevel) {
                    case 1:
                        return [ENEMY_TYPE.PATROL_DRONE, ENEMY_TYPE.NODE_WISP];
                    case 2:
                        return [ENEMY_TYPE.PATROL_DRONE, ENEMY_TYPE.CORROSION_DRONE, ENEMY_TYPE.CRYSTAL_LEECH];
                    case 3:
                        return [ENEMY_TYPE.SENTINEL_CONSTRUCT, ENEMY_TYPE.SHIELD_BEARER, ENEMY_TYPE.CORROSION_DRONE];
                    case 4:
                        return [ENEMY_TYPE.GRAVITY_SKITTER, ENEMY_TYPE.SENTINEL_CONSTRUCT, ENEMY_TYPE.ARCHITECT_SHARD];
                    case 5:
                        return [ENEMY_TYPE.ARCHITECT_SHARD, ENEMY_TYPE.GRAVITY_SKITTER, ENEMY_TYPE.SENTINEL_CONSTRUCT];
                    default:
                        return [ENEMY_TYPE.PATROL_DRONE];
                }
            }

            checkTileCollision(x, y) {
                const tileX = Math.floor(x / TILE_SIZE);
                const tileY = Math.floor(y / TILE_SIZE);

                return this.level.grid[tileY] && this.level.grid[tileY][tileX] !== TILE_TYPE.EMPTY;
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'KeyR') {
                        // Remove overlays and restart cleanly
                        this.removeAllOverlays();
                        this.restartLevel();
                    }
                });
            }

            removeAllOverlays() {
                const whispers = document.querySelectorAll('.whisper-overlay');
                whispers.forEach(el => el.remove());
                const bossBars = document.querySelectorAll('.boss-health-bar');
                bossBars.forEach(el => el.remove());
            }

            update(dt) {
                if (this.gameState === GAME_STATE.WHISPER || this.gameState === GAME_STATE.MENU) {
                    return;
                }

                // FPS smoothing
                const currentFPS = dt > 0 ? 1 / dt : 0;
                this.fpsSmoothed = this.fpsSmoothed * 0.9 + currentFPS * 0.1;

                this.bgTime += dt;

                // Update highlight timer
                if (this.highlightTimer > 0) {
                    this.highlightTimer -= dt;
                    if (this.highlightTimer <= 0) {
                        this.lastAttackerIndex = null;
                        this.highlightTimer = 0;
                    }
                }

                // Update player
                if (this.player && this.player.active) {
                    this.player.update(this.inputSystem, this, dt);
                } else {
                    this.gameState = GAME_STATE.GAME_OVER;
                }

                // Update boss
                if (this.boss && this.boss.active) {
                    this.boss.update(this, dt);
                } else if (this.boss && !this.boss.active) {
                    // Boss defeated - do not auto advance; unlock exit if not already unlocked
                    if (!this.bossDefeatedThisLevel) {
                        this.bossDefeatedThisLevel = true;
                        this.showNotification('Boss defeated! Exit is now available.', 'info');

                        // Show a whisper after boss defeat (ensure messages exist)
                        setTimeout(() => {
                            if (this.currentMessageIndex < this.whisperSystem.messages.length) {
                                const msg = this.whisperSystem.messages[this.currentMessageIndex++];
                                this.whisperSystem.active = true;
                                this.gameState = GAME_STATE.WHISPER;
                                this.whisperSystem.displayMessage(msg, this);
                            }
                        }, 1200);
                    }
                    this.boss = null; // remove from active boss tracking
                    this.gameState = GAME_STATE.PLAYING;
                }

                // Update enemies
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    if (enemy.active) {
                        enemy.update(this, dt);
                    } else {
                        this.enemies.splice(i, 1);
                    }
                }

                // Update projectiles
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const projectile = this.projectiles[i];
                    if (projectile.active) {
                        projectile.update(this, dt);
                    } else {
                        this.projectiles.splice(i, 1);
                    }
                }

                // Update bombs and detect chain explosions from current explosions
                for (let i = this.bombs.length - 1; i >= 0; i--) {
                    const bomb = this.bombs[i];
                    if (bomb.active) {
                        bomb.update(this, dt);
                    }
                }
                this.bombs = this.bombs.filter(b => b.active);

                // Update explosions
                for (let i = this.explosions.length - 1; i >= 0; i--) {
                    const explosion = this.explosions[i];
                    if (explosion.active) {
                        explosion.update(this, dt);
                    } else {
                        this.explosions.splice(i, 1);
                    }
                }

                // Update power-ups
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    if (powerUp.active) {
                        powerUp.update(this, dt);
                    }
                }
                this.powerUps = this.powerUps.filter(p => p.active);

                // Update effects
                for (let i = this.effects.length - 1; i >= 0; i--) {
                    const effect = this.effects[i];
                    if (effect.active) {
                        effect.update(this, dt);
                    } else {
                        this.effects.splice(i, 1);
                    }
                }

                // Update notifications
                for (let i = this.notifications.length - 1; i >= 0; i--) {
                    const notification = this.notifications[i];
                    notification.lifetime -= dt;
                    if (notification.lifetime <= 0) {
                        this.notifications.splice(i, 1);
                    }
                }

                // Check level completion via exit (only when unlocked)
                this.checkLevelCompletion();

                // Update UI
                this.updateUI();
            }

            // Exit unlocking logic: red if locked, green if unlocked
            isExitUnlocked() {
                // Conditions: either defeat boss on a level that had a boss, OR collect all keycard fragments required (2 per level), AND all enemies cleared.
                let hasBoss = !!this.level.bossData;
                const bossDefeated = this.bossDefeatedThisLevel && (!this.boss); // no active boss and was defeated this level
                const fragmentsNeeded = 2;
                const enoughFragments = this.player.keycardFragments >= fragmentsNeeded;

                // All enemies must be down
                const allEnemiesDown = this.enemies.length === 0;

                return (!hasBoss || bossDefeated) && enoughFragments && allEnemiesDown;
            }

            checkLevelCompletion() {
                if (!this.isExitUnlocked()) return;

                const playerTileX = Math.floor(this.player.x / TILE_SIZE);
                const playerTileY = Math.floor(this.player.y / TILE_SIZE);

                if (this.level.grid[playerTileY] &&
                    this.level.grid[playerTileY][playerTileX] === TILE_TYPE.EXIT) {

                    if (this.currentLevel < this.maxLevels) {
                        this.showNotification(`Level ${this.currentLevel} complete. Descending...`, 'info');
                        this.currentLevel++;
                        this.initLevel();
                    } else {
                        this.gameState = GAME_STATE.VICTORY;
                        // Final whisper on victory if available
                        if (this.currentMessageIndex < this.whisperSystem.messages.length) {
                            const msg = this.whisperSystem.messages[this.currentMessageIndex++];
                            this.whisperSystem.active = true;
                            this.whisperSystem.displayMessage(msg, this);
                        }
                    }
                }
            }

            updateUI() {
                const fpsEl = document.getElementById('fpsValue');
                if (fpsEl) {
                    fpsEl.textContent = Math.round(this.fpsSmoothed).toString();
                }

                document.getElementById('currentLevel').textContent = this.currentLevel;
                // Show bombs placed vs capacity properly
                document.getElementById('bombCount').textContent = this.player.bombs.length;
                document.getElementById('maxBombs').textContent = this.player.maxBombs;

                const healthPercent = (this.player.health / this.player.maxHealth) * 100;
                document.getElementById('healthFill').style.width = healthPercent + '%';

                // Update power-up info (map reveal removed)
                let powerInfoParts = [];
                if (this.player.remoteDetonation) powerInfoParts.push('Remote');
                if (this.player.piercingCharges) powerInfoParts.push('Piercing');
                if (this.player.shieldDrones.length > 0) powerInfoParts.push(`Shield x${this.player.shieldDrones.length}`);
                if (this.player.keycardFragments > 0) powerInfoParts.push(`Keys(${this.player.keycardFragments})`);

                document.getElementById('powerUpInfo').textContent = powerInfoParts.length ? powerInfoParts.join(', ') : 'None';

                // Render boss health bar when in boss fight or after defeat until next state
                if (this.gameState === GAME_STATE.BOSS_FIGHT || (this.boss && this.boss.active)) {
                    this.renderBossHealthBar();
                } else {
                    this.removeBossHealthBarIfAny();
                }
            }

            removeBossHealthBarIfAny() {
                const existing = document.querySelector('.boss-health-bar');
                if (existing) existing.remove();
            }

            showNotification(message, type = 'info') {
                const notification = {
                    message,
                    type,
                    lifetime: 3.0, // seconds
                    y: 20 + this.notifications.length * 25
                };
                this.notifications.push(notification);
            }

            render() {
                // Clear canvas with CRT effect background
                this.ctx.fillStyle = '#0a0a0a';
                this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Enhanced background
                this.renderBackground(this.ctx);

                // Add scanlines effect
                this.renderScanlines();

                // Render level tiles
                this.renderLevel();

                // Render entities in order
                this.powerUps.forEach(powerUp => powerUp.render(this.ctx));
                this.projectiles.forEach(projectile => projectile.render(this.ctx));
                this.bombs.forEach(bomb => bomb.render(this.ctx));
                this.explosions.forEach(explosion => explosion.render(this.ctx));
                this.effects.forEach(effect => effect.render(this.ctx));
                this.enemies.forEach(enemy => enemy.render(this.ctx));

                if (this.boss) {
                    this.boss.render(this.ctx);
                }

                if (this.player && this.player.active) {
                    this.player.render(this.ctx);
                }

                this.renderNotifications();
                this.renderGameState();
            }

            // Background: layered parallax grid + drifting neon dots + faint holo-archive particles
            renderBackground(ctx) {
                ctx.save();
                const t = this.bgTime;
                const theme = this.level.theme;

                // Base gradient influenced by theme
                let baseTop = '#05070b', baseBottom = '#0c0f16';
                if (theme === LEVEL_THEME.FRACTURE_MINES) { baseTop = '#0a0707'; baseBottom = '#1a1010'; }
                else if (theme === LEVEL_THEME.ECHO_VAULT) { baseTop = '#04080d'; baseBottom = '#0a1422'; }
                else if (theme === LEVEL_THEME.SYNTHESIS_SPIRE) { baseTop = '#03070c'; baseBottom = '#07111b'; }
                else if (theme === LEVEL_THEME.ARCHITECTS_LOOM) { baseTop = '#06040a'; baseBottom = '#0c0816'; }

                const grad = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
                grad.addColorStop(0, baseTop);
                grad.addColorStop(1, baseBottom);
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Parallax neon grid
                this.drawParallaxGrid(ctx, t * 10, 120, 'rgba(0,255,255,0.06)', 0.5);
                this.drawParallaxGrid(ctx, t * 20, 60, 'rgba(255,0,255,0.05)', 1.0);
                this.drawParallaxGrid(ctx, t * 30, 30, 'rgba(0,200,255,0.04)', 1.5);

                // Floating dust/particles
                this.drawNeonDust(ctx, t);

                // Theme-specific ambience
                if (theme === LEVEL_THEME.ECHO_VAULT) {
                    this.drawHoloStreams(ctx, t);
                } else if (theme === LEVEL_THEME.FRACTURE_MINES) {
                    this.drawSteamHaze(ctx, t);
                } else if (theme === LEVEL_THEME.SYNTHESIS_SPIRE) {
                    this.drawPlasmaArcs(ctx, t);
                } else if (theme === LEVEL_THEME.ARCHITECTS_LOOM) {
                    this.drawRealityWaves(ctx, t);
                }
                ctx.restore();
            }

            drawParallaxGrid(ctx, offset, spacing, color, alpha) {
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;

                const o = offset % spacing;
                for (let x = -o; x < CANVAS_WIDTH; x += spacing) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, CANVAS_HEIGHT);
                    ctx.stroke();
                }
                for (let y = -o; y < CANVAS_HEIGHT; y += spacing) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(CANVAS_WIDTH, y);
                    ctx.stroke();
                }
                ctx.restore();
            }

            drawNeonDust(ctx, t) {
                const count = 80;
                ctx.save();
                for (let i = 0; i < count; i++) {
                    const px = (i * 97 + (t * 20)) % CANVAS_WIDTH;
                    const py = (i * 53 + (t * 30)) % CANVAS_HEIGHT;
                    const a = Math.sin(t * 2 + i) * 0.5 + 0.5;
                    ctx.globalAlpha = 0.05 + 0.05 * a;
                    ctx.fillStyle = i % 3 === 0 ? '#00ffff' : (i % 3 === 1 ? '#ff00ff' : '#0088ff');
                    ctx.fillRect(px, py, 2, 2);
                }
                ctx.restore();
            }

            drawHoloStreams(ctx, t) {
                ctx.save();
                ctx.globalAlpha = 0.08;
                ctx.strokeStyle = '#55ddff';
                ctx.lineWidth = 2;
                for (let i = 0; i < 6; i++) {
                    const x = ((i * 150 + t * 40) % (CANVAS_WIDTH + 200)) - 100;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.bezierCurveTo(x + 60, CANVAS_HEIGHT * 0.25, x - 60, CANVAS_HEIGHT * 0.75, x + 40, CANVAS_HEIGHT);
                    ctx.stroke();
                }
                ctx.restore();
            }

            drawSteamHaze(ctx, t) {
                ctx.save();
                const bands = 5;
                for (let i = 0; i < bands; i++) {
                    const y = (i / bands) * CANVAS_HEIGHT + Math.sin(t * 0.5 + i) * 20;
                    const grad = ctx.createLinearGradient(0, y - 30, 0, y + 30);
                    grad.addColorStop(0, 'rgba(200,200,220,0)');
                    grad.addColorStop(0.5, `rgba(160,160,200,${0.06 + 0.03 * Math.sin(t + i)})`);
                    grad.addColorStop(1, 'rgba(200,200,220,0)');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, y - 30, CANVAS_WIDTH, 60);
                }
                ctx.restore();
            }

            drawPlasmaArcs(ctx, t) {
                ctx.save();
                ctx.globalAlpha = 0.12;
                ctx.strokeStyle = '#44ccff';
                for (let i = 0; i < 8; i++) {
                    const x = ((i * 100 + t * 50) % (CANVAS_WIDTH + 100)) - 50;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x + 40, CANVAS_HEIGHT * 0.33);
                    ctx.lineTo(x - 30, CANVAS_HEIGHT * 0.66);
                    ctx.lineTo(x + 20, CANVAS_HEIGHT);
                    ctx.stroke();
                }
                ctx.restore();
            }

            drawRealityWaves(ctx, t) {
                ctx.save();
                ctx.globalAlpha = 0.08;
                for (let i = 0; i < 3; i++) {
                    const r = 120 + i * 80 + Math.sin(t * 1.5 + i) * 20;
                    ctx.strokeStyle = i % 2 === 0 ? '#aa88ff' : '#ffffff';
                    ctx.beginPath();
                    ctx.arc(CANVAS_WIDTH * 0.5, CANVAS_HEIGHT * 0.5, r, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
            }

            renderScanlines() {
                this.ctx.save();
                this.ctx.globalAlpha = 0.1;
                this.ctx.fillStyle = '#00ffff';

                for (let y = 0; y < CANVAS_HEIGHT; y += 4) {
                    this.ctx.fillRect(0, y, CANVAS_WIDTH, 1);
                }

                this.ctx.restore();
            }

            renderLevel() {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const tileType = this.level.grid[y][x];
                        const screenX = x * TILE_SIZE;
                        const screenY = y * TILE_SIZE;

                        switch (tileType) {
                            case TILE_TYPE.WALL_SOLID:
                                this.renderSolidWall(screenX, screenY);
                                break;
                            case TILE_TYPE.WALL_DESTRUCTIBLE:
                                this.renderDestructibleWall(screenX, screenY);
                                break;
                            case TILE_TYPE.EXIT:
                                this.renderExit(screenX, screenY);
                                break;
                            case TILE_TYPE.POWERUP:
                                this.renderPowerUpTile(screenX, screenY);
                                break;
                            case TILE_TYPE.HAZARD_STEAM:
                                this.renderSteamHazard(screenX, screenY);
                                break;
                            case TILE_TYPE.HAZARD_CONVEYOR:
                                this.renderConveyorBelt(screenX, screenY);
                                break;
                            case TILE_TYPE.HAZARD_PLASMA:
                                this.renderPlasmaVent(screenX, screenY);
                                break;
                            case TILE_TYPE.GRAVITY_ZONE:
                                this.renderGravityZone(screenX, screenY);
                                break;
                        }
                    }
                }
            }

            renderSolidWall(x, y) {
                // Layered metallic panel with rivets and scuffs
                this.ctx.fillStyle = '#1c232a';
                this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

                const g = this.ctx.createLinearGradient(x, y, x + TILE_SIZE, y + TILE_SIZE);
                g.addColorStop(0, '#2a3238');
                g.addColorStop(0.5, '#3d474f');
                g.addColorStop(1, '#252c33');
                this.ctx.fillStyle = g;
                this.ctx.fillRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);

                // Edge bevel
                this.ctx.strokeStyle = 'rgba(255,255,255,0.06)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(x+1, y+1); this.ctx.lineTo(x+TILE_SIZE-2, y+1);
                this.ctx.moveTo(x+1, y+1); this.ctx.lineTo(x+1, y+TILE_SIZE-2);
                this.ctx.stroke();

                // Rivets
                this.ctx.fillStyle = '#6e7b85';
                const r = [3, 9, 16, 22];
                for (let i = 0; i < r.length; i++) {
                    this.ctx.beginPath();
                    this.ctx.arc(x + r[i%2], y + r[(i+1)%2], 1.5, 0, Math.PI*2);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.arc(x + TILE_SIZE - r[(i+1)%2], y + TILE_SIZE - r[i%2], 1.5, 0, Math.PI*2);
                    this.ctx.fill();
                }

                // Panel seams
                this.ctx.strokeStyle = 'rgba(0,0,0,0.35)';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([4, 3]);
                this.ctx.beginPath();
                this.ctx.moveTo(x + TILE_SIZE/2, y + 2);
                this.ctx.lineTo(x + TILE_SIZE/2, y + TILE_SIZE - 2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }

            renderDestructibleWall(x, y) {
                // Corroded maintenance panel with caution stripes and exposed wires
                this.ctx.fillStyle = '#6b4a2f'; // rust base
                this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

                const g = this.ctx.createLinearGradient(x, y, x, y + TILE_SIZE);
                g.addColorStop(0, '#8b5e3c');
                g.addColorStop(1, '#553720');
                this.ctx.fillStyle = g;
                this.ctx.fillRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);

                // Caution stripes
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.rect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                this.ctx.clip();
                this.ctx.fillStyle = '#222';
                for (let i = -TILE_SIZE; i < TILE_SIZE * 2; i += 6) {
                    this.ctx.save();
                    this.ctx.translate(x, y);
                    this.ctx.rotate(-Math.PI / 4);
                    this.ctx.fillRect(i, 0, 3, TILE_SIZE * 2);
                    this.ctx.restore();
                }
                this.ctx.restore();

                // Warning symbol
                this.ctx.strokeStyle = '#ffcc00';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(x + 8, y + 10);
                this.ctx.lineTo(x + 24, y + 10);
                this.ctx.lineTo(x + 16, y + 22);
                this.ctx.closePath();
                this.ctx.stroke();

                // Exposed wires
                this.ctx.strokeStyle = '#ff4444';
                this.ctx.lineWidth = 1.5;
                this.ctx.beginPath();
                this.ctx.moveTo(x + 5, y + 16); this.ctx.lineTo(x + 12, y + 13); this.ctx.lineTo(x + 18, y + 18); this.ctx.lineTo(x + 26, y + 15);
                this.ctx.stroke();

                // Edge highlight
                this.ctx.strokeStyle = 'rgba(255,255,255,0.08)';
                this.ctx.strokeRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
            }

            renderExit(x, y) {
                const unlocked = this.isExitUnlocked();
                const color = unlocked ? '#00ff00' : '#ff0000';

                // Portal frame
                this.ctx.fillStyle = unlocked ? '#003322' : '#330000';
                this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

                // Inner glow
                const grad = this.ctx.createLinearGradient(x, y, x + TILE_SIZE, y + TILE_SIZE);
                grad.addColorStop(0, unlocked ? '#0a3' : '#a00');
                grad.addColorStop(1, unlocked ? '#0f8' : '#f33');
                this.ctx.fillStyle = grad;
                this.ctx.globalAlpha = 0.8;
                this.ctx.fillRect(x + 3, y + 3, TILE_SIZE - 6, TILE_SIZE - 6);
                this.ctx.globalAlpha = 1;

                // Animated portal swirl
                this.ctx.save();
                this.ctx.translate(x + TILE_SIZE/2, y + TILE_SIZE/2);
                const t = Date.now() * 0.005;
                for (let r = 6; r < 14; r += 3) {
                    this.ctx.strokeStyle = color;
                    this.ctx.globalAlpha = 0.4 + 0.1 * Math.sin(t + r);
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    for (let a = 0; a < Math.PI * 2; a += Math.PI / 12) {
                        const rr = r + Math.sin(a * 3 + t) * 1.5;
                        const px = Math.cos(a) * rr;
                        const py = Math.sin(a) * rr;
                        if (a === 0) this.ctx.moveTo(px, py); else this.ctx.lineTo(px, py);
                    }
                    this.ctx.closePath();
                    this.ctx.stroke();
                }
                this.ctx.restore();

                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 14px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('EXIT', x + TILE_SIZE / 2, y + TILE_SIZE / 2 + 5);

                this.ctx.shadowColor = color;
                this.ctx.shadowBlur = 10;
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
                this.ctx.shadowBlur = 0;
            }

            renderPowerUpTile(x, y) {
                // Energy slot with holo shimmer
                this.ctx.fillStyle = 'rgba(255, 255, 0, 0.12)';
                this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

                this.ctx.strokeStyle = '#ffee00';
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([2, 2]);
                this.ctx.strokeRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
                this.ctx.setLineDash([]);

                // Holo flicker
                const t = Date.now() * 0.01;
                this.ctx.globalAlpha = 0.35 + Math.sin(t) * 0.15;
                this.ctx.strokeStyle = '#ffff88';
                this.ctx.beginPath();
                this.ctx.moveTo(x + 4, y + 10);
                this.ctx.lineTo(x + TILE_SIZE - 4, y + 10);
                this.ctx.moveTo(x + 4, y + 20);
                this.ctx.lineTo(x + TILE_SIZE - 4, y + 20);
                this.ctx.stroke();
                this.ctx.globalAlpha = 1;
            }

            renderSteamHazard(x, y) {
                // Animated steam vents with wisps and pipes
                this.ctx.fillStyle = '#2b2d33';
                this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

                // Pipes
                this.ctx.strokeStyle = '#666b70';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(x + 4, y + 14); this.ctx.lineTo(x + TILE_SIZE - 4, y + 14);
                this.ctx.stroke();

                const time = Date.now() * 0.005;
                const alpha = Math.sin(time) * 0.2 + 0.35;
                for (let i = 0; i < 3; i++) {
                    this.ctx.fillStyle = `rgba(200, 210, 255, ${alpha * (1 - i*0.25)})`;
                    const ox = x + 6 + i * 8;
                    const oy = y + 16 + Math.sin(time * 2 + i) * 3;
                    this.ctx.beginPath();
                    this.ctx.arc(ox, oy, 5 + i, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // Warning chevrons
                this.ctx.fillStyle = 'rgba(255,255,255,0.08)';
                this.ctx.beginPath();
                this.ctx.moveTo(x + 6, y + 6); this.ctx.lineTo(x + 12, y + 10); this.ctx.lineTo(x + 6, y + 14); this.ctx.closePath();
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.moveTo(x + TILE_SIZE - 6, y + 6); this.ctx.lineTo(x + TILE_SIZE - 12, y + 10); this.ctx.lineTo(x + TILE_SIZE - 6, y + 14); this.ctx.closePath();
                this.ctx.fill();

                // Hazard border
                this.ctx.strokeStyle = '#ccccff';
                this.ctx.lineWidth = 1;
                this.ctx.globalAlpha = 0.6;
                this.ctx.strokeRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
                this.ctx.globalAlpha = 1;
            }

            renderConveyorBelt(x, y) {
                // Metallic belt with rollers and arrows
                this.ctx.fillStyle = '#2a2b2d';
                this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

                const time = Date.now() * 0.01;
                const offset = (time % 16);

                // Belt surface gradient
                const g = this.ctx.createLinearGradient(x, y, x + TILE_SIZE, y + TILE_SIZE);
                g.addColorStop(0, '#3c3e42');
                g.addColorStop(0.5, '#575b60');
                g.addColorStop(1, '#3c3e42');
                this.ctx.fillStyle = g;
                this.ctx.fillRect(x + 2, y + 6, TILE_SIZE - 4, TILE_SIZE - 12);

                // Moving arrows
                this.ctx.fillStyle = '#666b70';
                for (let i = 0; i < 4; i++) {
                    const ax = x + ((i * 8 - offset) % 16) + 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(ax + 2, y + 18);
                    this.ctx.lineTo(ax + 6, y + 14);
                    this.ctx.lineTo(ax + 10, y + 18);
                    this.ctx.closePath();
                    this.ctx.fill();
                }

                // Side rails
                this.ctx.strokeStyle = '#1a1b1d';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(x + 2, y + 6); this.ctx.lineTo(x + TILE_SIZE - 2, y + 6);
                this.ctx.moveTo(x + 2, y + TILE_SIZE - 6); this.ctx.lineTo(x + TILE_SIZE - 2, y + TILE_SIZE - 6);
                this.ctx.stroke();

                // Bolts
                this.ctx.fillStyle = '#84898f';
                const bolts = [[6, 6], [TILE_SIZE-6, 6], [6, TILE_SIZE-6], [TILE_SIZE-6, TILE_SIZE-6]];
                for (const [bx, by] of bolts) {
                    this.ctx.beginPath(); this.ctx.arc(x + bx, y + by, 1.5, 0, Math.PI*2); this.ctx.fill();
                }
            }

            renderPlasmaVent(x, y) {
                // Pulsing plasma aperture with energy arcs
                const time = Date.now() * 0.01;
                const intensity = Math.sin(time * 2) * 0.5 + 0.5;

                // Vent housing
                this.ctx.fillStyle = '#191b21';
                this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

                // Aperture gradient
                const grad = this.ctx.createRadialGradient(x + TILE_SIZE/2, y + TILE_SIZE/2, 2, x + TILE_SIZE/2, y + TILE_SIZE/2, 12);
                grad.addColorStop(0, 'rgba(255, 180, 255, 1)');
                grad.addColorStop(0.4, `rgba(255, 100, 255, ${0.7})`);
                grad.addColorStop(1, 'rgba(120, 0, 160, 0)');
                this.ctx.fillStyle = grad;
                this.ctx.globalAlpha = 0.7 + intensity * 0.3;
                this.ctx.beginPath();
                this.ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 10 + intensity * 3, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.globalAlpha = 1;

                // Energy arcs
                this.ctx.strokeStyle = 'rgba(255, 50, 255, 0.8)';
                this.ctx.lineWidth = 2;
                for (let i = 0; i < 4; i++) {
                    const a0 = time * 3 + i * (Math.PI / 2);
                    const a1 = a0 + Math.PI / 3;
                    this.ctx.beginPath();
                    this.ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, 12 + Math.sin(time * 5 + i) * 2, a0, a1);
                    this.ctx.stroke();
                }

                // Frame glow
                this.ctx.shadowColor = '#ff66ff';
                this.ctx.shadowBlur = 10 + intensity * 8;
                this.ctx.strokeStyle = '#ff00ff';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                this.ctx.shadowBlur = 0;
            }

            renderGravityZone(x, y) {
                const time = Date.now() * 0.005;
                const rotation = time % (Math.PI * 2);

                // Subtle platform
                this.ctx.fillStyle = 'rgba(70, 50, 120, 0.25)';
                this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);

                this.ctx.save();
                this.ctx.translate(x + TILE_SIZE/2, y + TILE_SIZE/2);
                this.ctx.rotate(rotation);

                this.ctx.strokeStyle = '#a88aff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, 12, 0, Math.PI * 2);
                this.ctx.stroke();

                // Orientation glyphs
                this.ctx.strokeStyle = '#ccb7ff';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(-8, 0); this.ctx.lineTo(-3, 0);
                this.ctx.moveTo(8, 0); this.ctx.lineTo(3, 0);
                this.ctx.moveTo(0, -8); this.ctx.lineTo(0, -3);
                this.ctx.moveTo(0, 8); this.ctx.lineTo(0, 3);
                this.ctx.stroke();

                this.ctx.restore();
            }

            renderNotifications() {
                for (let notification of this.notifications) {
                    const alpha = notification.lifetime / 3.0;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;

                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    this.ctx.fillRect(5, notification.y - 20, 340, 25);

                    let color = '#00ffff';
                    if (notification.type === 'powerup') color = '#ffff00';
                    else if (notification.type === 'danger') color = '#ff0000';

                    this.ctx.fillStyle = color;
                    this.ctx.font = '14px monospace';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(notification.message, 15, notification.y - 3);

                    this.ctx.restore();
                }
            }

            renderBossHealthBar() {
                // Remove existing boss health bar each frame to keep DOM lean
                const existing = document.querySelector('.boss-health-bar');
                if (existing) {
                    existing.remove();
                }

                // Only render when boss is active
                if (!this.boss || !this.boss.active) return;

                const healthBar = document.createElement('div');
                healthBar.className = 'boss-health-bar';

                const healthFill = document.createElement('div');
                healthFill.className = 'boss-health-fill';
                healthFill.style.width = (this.boss.health / this.boss.maxHealth * 100) + '%';

                healthBar.appendChild(healthFill);
                document.body.appendChild(healthBar);
            }

            renderGameState() {
                this.ctx.save();

                switch (this.gameState) {
                    case GAME_STATE.GAME_OVER:
                        this.renderOverlay('GAME OVER', 'Press R to restart');
                        break;
                    case GAME_STATE.VICTORY:
                        this.renderOverlay('VICTORY!', 'You have restored the Grid!');
                        break;
                }

                this.ctx.restore();
            }

            renderOverlay(title, subtitle) {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                this.ctx.fillStyle = '#00ffff';
                this.ctx.font = 'bold 36px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(title, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);

                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '18px monospace';
                this.ctx.fillText(subtitle, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            }

            // Restart level: reset all power-ups and stats
            restartLevel() {
                this.currentMessageIndex = this.levelMessageIndex;

                if (this.player) {
                    this.player.resetToBase();
                }
                // Clear overlays (whisper, game over), boss bars, and notifications
                this.removeAllOverlays();
                this.notifications.length = 0;
                this.gameState = GAME_STATE.PLAYING;
                this.initLevel();
            }

            gameLoop(now) {
                const dt = Math.min((now - this.lastTime) / 1000, 0.033); // clamp dt to ~30 FPS max step
                this.lastTime = now;

                this.update(dt);
                this.render();
                this.inputSystem.update();

                requestAnimationFrame((t) => this.gameLoop(t));
            }
        }

        // Drawing helpers
        function roundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
            if (ctx.fillStyle) ctx.fill();
        }

        // Enemy model renderers (significantly improved models)
        function renderPatrolDroneModel(ctx, enemy, color, glowColor) {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(enemy.x, enemy.y + 10, 9, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body disk
            const grad = ctx.createRadialGradient(enemy.x, enemy.y, 2, enemy.x, enemy.y, 11);
            grad.addColorStop(0, '#ff6688');
            grad.addColorStop(1, color);
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, 10, 0, Math.PI * 2);
            ctx.fill();

            // Eye
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(enemy.x + 3, enemy.y - 2, 2, 0, Math.PI * 2);
            ctx.fill();

            // Rotating fins (3)
            ctx.strokeStyle = glowColor;
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                const a = enemy.animationTime * 6 + i * Math.PI * 2 / 3;
                const x1 = enemy.x + Math.cos(a) * 6;
                const y1 = enemy.y + Math.sin(a) * 6;
                const x2 = enemy.x + Math.cos(a) * 12;
                const y2 = enemy.y + Math.sin(a) * 12;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            // Glow rim
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 8;
            ctx.strokeStyle = glowColor;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, 10, 0, Math.PI * 2);
            ctx.stroke();
        }

        function renderSentinelConstructModel(ctx, enemy, color, glowColor) {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.ellipse(enemy.x, enemy.y + 12, 11, 7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body hull
            ctx.fillStyle = '#aa5500';
            roundedRect(ctx, enemy.x - 12, enemy.y - 14, 24, 22, 3);

            // Armor plates
            ctx.fillStyle = '#cc7700';
            roundedRect(ctx, enemy.x - 10, enemy.y - 10, 20, 8, 2);
            ctx.fillStyle = '#ee9900';
            roundedRect(ctx, enemy.x - 8, enemy.y + 2, 16, 6, 2);

            // Legs
            ctx.fillStyle = '#774400';
            roundedRect(ctx, enemy.x - 9, enemy.y + 8, 6, 8, 2);
            roundedRect(ctx, enemy.x + 3, enemy.y + 8, 6, 8, 2);

            // Head and eye visor
            ctx.fillStyle = '#dd8800';
            roundedRect(ctx, enemy.x - 9, enemy.y - 18, 18, 8, 2);
            const eyeGrad = ctx.createLinearGradient(enemy.x - 6, enemy.y - 15, enemy.x + 6, enemy.y - 15);
            eyeGrad.addColorStop(0, '#ff4444');
            eyeGrad.addColorStop(1, '#ff8888');
            ctx.fillStyle = eyeGrad;
            roundedRect(ctx, enemy.x - 5, enemy.y - 16, 10, 5, 2);

            // Glow seams
            ctx.strokeStyle = glowColor;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(enemy.x - 11, enemy.y - 6); ctx.lineTo(enemy.x + 11, enemy.y - 6);
            ctx.moveTo(enemy.x - 9, enemy.y + 2); ctx.lineTo(enemy.x + 9, enemy.y + 2);
            ctx.stroke();

            // Shadow glow
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 12;
            ctx.strokeStyle = glowColor;
            ctx.strokeRect(enemy.x - 12, enemy.y - 14, 24, 22);
        }

        function renderCorrosionDroneModel(ctx, enemy, color, glowColor) {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(enemy.x, enemy.y + 10, 9, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Organic-techno body
            ctx.fillStyle = '#33cc66';
            roundedRect(ctx, enemy.x - 8, enemy.y - 10, 16, 16, 6);

            // Vein patterns
            ctx.strokeStyle = '#00ff44';
            ctx.lineWidth = 1;
            for (let i = -2; i <= 2; i++) {
                ctx.beginPath();
                ctx.moveTo(enemy.x - 6, enemy.y - 6 + i);
                ctx.quadraticCurveTo(enemy.x, enemy.y - 8 + i * 1.5, enemy.x + 6, enemy.y - 6 + i);
                ctx.stroke();
            }

            // Acid drip tip
            ctx.fillStyle = '#88ff88';
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y + 8, 2, 0, Math.PI * 2);
            ctx.fill();

            // Legs (6)
            ctx.strokeStyle = glowColor;
            ctx.lineWidth = 2;
            for (let i = 0; i < 6; i++) {
                const a = Math.PI * 2 * i / 6 + enemy.animationTime * 2;
                const lx = enemy.x + Math.cos(a) * 7;
                const ly = enemy.y + Math.sin(a) * 7;
                ctx.beginPath();
                ctx.moveTo(enemy.x, enemy.y);
                ctx.lineTo(lx, ly);
                ctx.stroke();
            }

            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 8;
            ctx.strokeStyle = glowColor;
            ctx.lineWidth = 1;
            roundedRect(ctx, enemy.x - 8, enemy.y - 10, 16, 16, 6);
        }

        function renderNodeWispModel(ctx, enemy, color, glowColor) {
            // Shadow faint
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath();
            ctx.ellipse(enemy.x, enemy.y + 8, 7, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Wispy orb with data streams
            const pulse = (Math.sin(enemy.animationTime * 6) + 1) * 0.5;
            const rad = 8 + pulse * 3;

            const grad = ctx.createRadialGradient(enemy.x, enemy.y, 2, enemy.x, enemy.y, rad);
            grad.addColorStop(0, '#bb99ff');
            grad.addColorStop(0.6, color);
            grad.addColorStop(1, '#440088');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, rad, 0, Math.PI * 2);
            ctx.fill();

            // Data streams
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                const a = enemy.animationTime * 3 + i * Math.PI * 2 / 3;
                ctx.beginPath();
                ctx.moveTo(enemy.x, enemy.y);
                ctx.lineTo(enemy.x + Math.cos(a) * (rad + 4), enemy.y + Math.sin(a) * (rad + 4));
                ctx.stroke();
            }

            // Vulnerability halo during vulnerability window
            if (enemy.vulnerabilityTimer > 0) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, rad + 6, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // Glow
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 10;
            ctx.strokeStyle = glowColor;
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, rad, 0, Math.PI * 2);
            ctx.stroke();
        }

        function renderCrystalLeechModel(ctx, enemy, color, glowColor) {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.beginPath();
            ctx.ellipse(enemy.x, enemy.y + 10, 10, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Segmented crystalline body
            const segments = 6;
            for (let i = 0; i < segments; i++) {
                const off = (i - 2) * 4;
                const segColor = i % 2 === 0 ? '#00d9ff' : '#77faff';
                ctx.fillStyle = segColor;
                roundedRect(ctx, enemy.x - 8, enemy.y - 10 + off, 16, 5, 2);

                ctx.strokeStyle = '#99ffff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(enemy.x - 8, enemy.y - 7 + off);
                ctx.lineTo(enemy.x + 8, enemy.y - 7 + off);
                ctx.stroke();
            }

            // Head with drill
            ctx.fillStyle = '#00ccff';
            roundedRect(ctx, enemy.x - 6, enemy.y - 15, 12, 8, 3);
            ctx.fillStyle = '#88ffff';
            ctx.beginPath();
            ctx.moveTo(enemy.x, enemy.y - 15);
            ctx.lineTo(enemy.x - 4, enemy.y - 22);
            ctx.lineTo(enemy.x + 4, enemy.y - 22);
            ctx.closePath();
            ctx.fill();

            // Glow
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 10;
            ctx.strokeStyle = '#66ffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, 12, 0, Math.PI * 2);
            ctx.stroke();
        }

        function renderShieldBearerModel(ctx, enemy, color, glowColor) {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.ellipse(enemy.x, enemy.y + 12, 12, 7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body
            ctx.fillStyle = '#ccaa00';
            roundedRect(ctx, enemy.x - 10, enemy.y - 16, 20, 26, 4);

            // Helmet visor
            const helmGrad = ctx.createLinearGradient(enemy.x - 8, enemy.y - 14, enemy.x + 8, enemy.y - 14);
            helmGrad.addColorStop(0, '#ffee88');
            helmGrad.addColorStop(1, '#ffffcc');
            ctx.fillStyle = helmGrad;
            roundedRect(ctx, enemy.x - 8, enemy.y - 14, 16, 8, 3);

            // Left arm (shield generator)
            ctx.fillStyle = '#aa8800';
            roundedRect(ctx, enemy.x - 16, enemy.y - 8, 8, 12, 3);
            // Shield disk
            if (enemy.shieldActive) {
                ctx.strokeStyle = '#ffee55';
                ctx.lineWidth = 3;
                ctx.setLineDash([4, 2]);
                const a0 = enemy.shieldRotation % (Math.PI * 2);
                ctx.beginPath();
                ctx.arc(enemy.x - 18, enemy.y - 2, 10, a0, a0 + Math.PI * 0.7);
                ctx.stroke();
                ctx.setLineDash([]);
            } else {
                ctx.strokeStyle = '#ffee55';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(enemy.x - 18, enemy.y - 2, 8, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Right arm (weapon)
            ctx.fillStyle = '#aa8800';
            roundedRect(ctx, enemy.x + 8, enemy.y - 6, 8, 10, 3);
            ctx.fillStyle = '#ffee88';
            roundedRect(ctx, enemy.x + 12, enemy.y - 4, 8, 6, 2);

            // Legs
            ctx.fillStyle = '#998800';
            roundedRect(ctx, enemy.x - 8, enemy.y + 10, 7, 8, 2);
            roundedRect(ctx, enemy.x + 1, enemy.y + 10, 7, 8, 2);

            // Glow
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 12;
            ctx.strokeStyle = '#ffee88';
            ctx.lineWidth = 2;
            ctx.strokeRect(enemy.x - 10, enemy.y - 16, 20, 26);
        }

        function renderGravitySkitterModel(ctx, enemy, color, glowColor) {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.beginPath();
            ctx.ellipse(enemy.x, enemy.y + 10, 10, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body core
            ctx.fillStyle = '#cc33cc';
            roundedRect(ctx, enemy.x - 9, enemy.y - 9, 18, 14, 5);

            // Gravity field ring
            ctx.strokeStyle = '#ff66ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, 13, 0, Math.PI * 2);
            ctx.stroke();

            // Legs (6)
            ctx.strokeStyle = glowColor;
            ctx.lineWidth = 2;
            const legSpread = 3;
            for (let i = -legSpread; i <= legSpread; i++) {
                const len = 8 + Math.abs(i) * 1.5;
                const a1 = Math.PI / 4 * (i / legSpread);
                const a2 = a1 + Math.PI * (0.9 + 0.1 * Math.sin(enemy.animationTime * 4));
                const x1 = enemy.x + Math.cos(a1) * 7;
                const y1 = enemy.y + Math.sin(a1) * 5;
                const x2 = x1 + Math.cos(a2) * len;
                const y2 = y1 + Math.sin(a2) * len;
                ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
            }

            // Eye
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(enemy.x + 4, enemy.y - 2, 2, 0, Math.PI * 2);
            ctx.fill();

            // Glow
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 12;
            ctx.strokeStyle = '#ff99ff';
            ctx.lineWidth = 1.5;
            roundedRect(ctx, enemy.x - 9, enemy.y - 9, 18, 14, 5);
        }

        function renderArchitectShardModel(ctx, enemy, color, glowColor) {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(enemy.x, enemy.y + 10, 8, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Rotating shard polygon
            const sides = 6;
            const r = 11 + Math.sin(enemy.animationTime * 3) * 1.5;
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            ctx.rotate((enemy.animationTime * 2) % (Math.PI * 2));

            for (let i = 0; i < 2; i++) {
                ctx.rotate(Math.PI / 6);
                ctx.fillStyle = i === 0 ? '#ffffff' : '#ccddff';
                ctx.beginPath();
                for (let j = 0; j < sides; j++) {
                    const a = j * Math.PI * 2 / sides;
                    const px = Math.cos(a) * r;
                    const py = Math.sin(a) * (r * 0.6);
                    if (j === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();

                // Edge glow
                ctx.strokeStyle = glowColor;
                ctx.lineWidth = 1.5;
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = 8;
                ctx.stroke();
            }

            ctx.restore();

            // Core pulse
            ctx.fillStyle = '#aabbff';
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, 3 + Math.sin(enemy.animationTime * 5) * 1, 0, Math.PI * 2);
            ctx.fill();
        }

        // Boss model renderers (significantly improved models)
        function renderSentinelNodeAlphaModel(ctx, boss) {
            // Central core
            const coreGrad = ctx.createRadialGradient(boss.x, boss.y, 5, boss.x, boss.y, 25);
            coreGrad.addColorStop(0, '#ffaaaa');
            coreGrad.addColorStop(1, '#ff4444');
            ctx.fillStyle = coreGrad;
            roundedRect(ctx, boss.x - 18, boss.y - 18, 36, 36, 8);

            // Rotating arms with distinct heads
            for (let i = 0; i < 3; i++) {
                const angle = boss.armRotation + (Math.PI * 2 * i) / 3;
                const armX = boss.x + Math.cos(angle) * 42;
                const armY = boss.y + Math.sin(angle) * 42;

                // Arm shaft
                ctx.strokeStyle = '#ffaa33';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(boss.x, boss.y);
                ctx.lineTo(armX, armY);
                ctx.stroke();

                // Arm head variants: laser, crusher, projector
                ctx.save();
                ctx.translate(armX, armY);
                ctx.rotate(angle);
                if (i === 0) {
                    // Laser
                    ctx.fillStyle = '#ff0000';
                    roundedRect(ctx, -6, -4, 14, 8, 3);
                    ctx.fillStyle = '#ffffff';
                    roundedRect(ctx, -2, -2, 8, 4, 2);
                } else if (i === 1) {
                    // Crusher
                    ctx.fillStyle = '#aa5500';
                    roundedRect(ctx, -7, -5, 16, 10, 3);
                } else {
                    // Projector
                    ctx.fillStyle = '#ffee44';
                    roundedRect(ctx, -5, -6, 12, 12, 3);
                    ctx.fillStyle = '#ffffff';
                    roundedRect(ctx, -2, -3, 6, 6, 2);
                }
                ctx.restore();

                // Joint glow
                ctx.shadowColor = '#ff5522';
                ctx.shadowBlur = 8;
                ctx.strokeStyle = '#ffcc55';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(boss.x, boss.y, 42, angle - 0.3, angle + 0.3);
                ctx.stroke();
            }

            // Outer ring
            ctx.strokeStyle = '#ffaa33';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 6]);
            ctx.beginPath();
            ctx.arc(boss.x, boss.y, 52, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function renderWardenK79Model(ctx, boss) {
            // Shadow pad
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            roundedRect(ctx, boss.x - 60, boss.y + 40, 120, 12, 6);

            // Main chassis
            ctx.fillStyle = '#660000';
            roundedRect(ctx, boss.x - 30, boss.y - 35, 60, 60, 8);

            // Armor plates (modular)
            ctx.fillStyle = '#990000';
            for (let i = 0; i < 4; i++) {
                const a = i * Math.PI / 2 + 0.3;
                const px = boss.x + Math.cos(a) * 22;
                const py = boss.y - 5 + Math.sin(a) * 18;
                roundedRect(ctx, px - 12, py - 8, 24, 16, 4);
            }

            // Head visor
            const visorGrad = ctx.createLinearGradient(boss.x - 10, boss.y - 25, boss.x + 10, boss.y - 25);
            visorGrad.addColorStop(0, '#ff2222');
            visorGrad.addColorStop(1, '#ff6666');
            ctx.fillStyle = visorGrad;
            roundedRect(ctx, boss.x - 12, boss.y - 28, 24, 12, 4);

            // Shoulders
            ctx.fillStyle = '#880000';
            roundedRect(ctx, boss.x - 40, boss.y - 20, 16, 20, 6);
            roundedRect(ctx, boss.x + 24, boss.y - 20, 16, 20, 6);

            // Cannon arms
            ctx.fillStyle = '#aa1111';
            roundedRect(ctx, boss.x - 34, boss.y - 10, 26, 10, 5); // left
            roundedRect(ctx, boss.x + 8, boss.y - 10, 26, 10, 5);  // right

            // Legs
            ctx.fillStyle = '#550000';
            roundedRect(ctx, boss.x - 18, boss.y + 20, 14, 24, 6);
            roundedRect(ctx, boss.x + 4, boss.y + 20, 14, 24, 6);

            // Shield drone (if any)
            if (boss.shieldDrone) {
                const a = Date.now() * 0.005;
                const dx = Math.cos(a) * 20;
                const dy = Math.sin(a) * 20;
                ctx.fillStyle = '#ffee88';
                roundedRect(ctx, boss.x + dx - 6, boss.y + dy - 6, 12, 12, 3);
                ctx.strokeStyle = '#fff5aa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(boss.x + dx, boss.y + dy, 9, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Glow outline
            ctx.shadowColor = '#ff4444';
            ctx.shadowBlur = 15;
            ctx.strokeStyle = '#ff8888';
            ctx.lineWidth = 3;
            ctx.strokeRect(boss.x - 30, boss.y - 35, 60, 60);
        }

        function renderArchitectPrimeModel(ctx, boss) {
            // Platform distortion
            const warpR = 60 + Math.sin(boss.animationTime * 2) * 10;
            ctx.strokeStyle = 'rgba(170,120,255,0.6)';
            ctx.lineWidth = 3;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(boss.x, boss.y, warpR + i * 15, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Central core
            const corePulse = 1 + Math.sin(boss.animationTime * 3) * 0.1;
            ctx.fillStyle = '#bbaaff';
            roundedRect(ctx, boss.x - 20, boss.y - 20, 40, 40, 10);

            // Organic-techno ribs
            ctx.strokeStyle = '#ddccff';
            ctx.lineWidth = 3;
            for (let i = -2; i <= 2; i++) {
                ctx.beginPath();
                ctx.moveTo(boss.x - 18, boss.y + i * 8);
                ctx.quadraticCurveTo(boss.x, boss.y + i * 12 * corePulse, boss.x + 18, boss.y + i * 8);
                ctx.stroke();
            }

            // Orbiting shards (Phase 1/2)
            for (let i = 0; i < 5; i++) {
                const a = boss.animationTime * 1.2 + i * Math.PI * 2 / 5;
                const sx = boss.x + Math.cos(a) * 55;
                const sy = boss.y + Math.sin(a) * 35;
                ctx.save();
                ctx.translate(sx, sy);
                ctx.rotate(a);
                ctx.fillStyle = i % 2 === 0 ? '#ffffff' : '#cce0ff';
                ctx.beginPath();
                ctx.moveTo(0, -8);
                ctx.lineTo(12, 0);
                ctx.lineTo(0, 8);
                ctx.lineTo(-12, 0);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            // Exposed core in later phases
            if (boss.coreExposure) {
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(boss.x, boss.y, 10 + Math.sin(boss.animationTime * 6) * 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Reality distortion rings near boss
            ctx.strokeStyle = '#aa88ff';
            ctx.lineWidth = 2;
            for (let r = 30; r <= 70; r += 20) {
                ctx.beginPath();
                ctx.arc(boss.x, boss.y, r, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // Initialize game when page loads
        window.addEventListener('load', () => {
            new Game();
        });
    </script>
</body>
</html>